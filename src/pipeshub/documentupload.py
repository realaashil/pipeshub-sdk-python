"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from pipeshub import errors, models, utils
from pipeshub._hooks import HookContext
from pipeshub.types import OptionalNullable, UNSET
from pipeshub.utils import get_security_from_env
from pipeshub.utils.unmarshal_json_response import unmarshal_json_response
from typing import Mapping, Optional, Union


class DocumentUpload(BaseSDK):
    def upload(
        self,
        *,
        document_name: str,
        is_versioned_file: models.IsVersionedFile,
        file: Union[models.UploadDocumentFile, models.UploadDocumentFileTypedDict],
        document_path: Optional[str] = None,
        alternate_document_name: Optional[str] = None,
        permissions: Optional[models.UploadDocumentPermissions] = "owner",
        custom_metadata: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UploadDocumentResponse:
        r"""Upload a new document

        Upload a new document to PipesHub storage. Supports multiple storage backends including S3, Azure Blob, and local storage.<br><br>
        <b>Overview:</b><br>
        This endpoint handles document uploads with automatic processing, metadata extraction, and optional versioning. It's the primary endpoint for adding new files to PipesHub.<br><br>
        <b>Upload Flow:</b><br>
        <ol>
        <li>Client sends file with metadata via multipart/form-data</li>
        <li>Document metadata saved to database</li>
        <li>Returns document object with storage URLs</li>
        </ol>
        <b>File Size Limits:</b><br>
        <ul>
        <li><b>Maximum:</b> 1GB (1,073,741,824 bytes)</li>
        <li><b>Large file threshold:</b> 10MB (triggers direct upload flow)</li>
        </ul>
        <b>Supported File Types:</b><br>
        <ul>
        <li><b>Documents:</b> PDF, DOCX, DOC, XLSX, XLS, PPTX, PPT, TXT, MD, CSV</li>
        <li><b>Images:</b> PNG, JPG, JPEG, GIF, WebP, SVG, BMP, TIFF</li>
        <li><b>Videos:</b> MP4, AVI, MOV, MKV, WebM</li>
        <li><b>Audio:</b> MP3, WAV, FLAC, AAC</li>
        <li><b>Archives:</b> ZIP, RAR, 7Z, TAR, GZ</li>
        </ul>
        <b>Version Control:</b><br>
        Set <code>isVersionedFile: \"true\"</code> to enable version tracking. Versioned documents maintain full history of all changes.<br><br>
        <b>Response Headers:</b><br>
        <ul>
        <li><code>x-document-id</code>: Unique document identifier</li>
        <li><code>x-document-name</code>: Document name as stored</li>
        </ul>
        <b>Storage Backends:</b><br>
        Automatically routes to configured storage: Amazon S3, Azure Blob Storage, or Local filesystem.


        :param document_name: Display name for the document
        :param is_versioned_file: Enable version control for this document
        :param file: The file to upload (max 1GB)
        :param document_path: Virtual folder path for organization
        :param alternate_document_name: Alternative name for search/display
        :param permissions: Default permission level for shared access
        :param custom_metadata: JSON string of custom key-value metadata
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UploadDocumentRequest(
            document_name=document_name,
            document_path=document_path,
            alternate_document_name=alternate_document_name,
            permissions=permissions,
            custom_metadata=custom_metadata,
            is_versioned_file=is_versioned_file,
            file=utils.get_pydantic_model(file, models.UploadDocumentFile),
        )

        req = self._build_request(
            method="POST",
            path="/document/upload",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "multipart", models.UploadDocumentRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="uploadDocument",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["308", "400", "401", "413", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return models.UploadDocumentResponse(
                result=unmarshal_json_response(models.Document, http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "308", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["400", "401", "413", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def upload_async(
        self,
        *,
        document_name: str,
        is_versioned_file: models.IsVersionedFile,
        file: Union[models.UploadDocumentFile, models.UploadDocumentFileTypedDict],
        document_path: Optional[str] = None,
        alternate_document_name: Optional[str] = None,
        permissions: Optional[models.UploadDocumentPermissions] = "owner",
        custom_metadata: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UploadDocumentResponse:
        r"""Upload a new document

        Upload a new document to PipesHub storage. Supports multiple storage backends including S3, Azure Blob, and local storage.<br><br>
        <b>Overview:</b><br>
        This endpoint handles document uploads with automatic processing, metadata extraction, and optional versioning. It's the primary endpoint for adding new files to PipesHub.<br><br>
        <b>Upload Flow:</b><br>
        <ol>
        <li>Client sends file with metadata via multipart/form-data</li>
        <li>Document metadata saved to database</li>
        <li>Returns document object with storage URLs</li>
        </ol>
        <b>File Size Limits:</b><br>
        <ul>
        <li><b>Maximum:</b> 1GB (1,073,741,824 bytes)</li>
        <li><b>Large file threshold:</b> 10MB (triggers direct upload flow)</li>
        </ul>
        <b>Supported File Types:</b><br>
        <ul>
        <li><b>Documents:</b> PDF, DOCX, DOC, XLSX, XLS, PPTX, PPT, TXT, MD, CSV</li>
        <li><b>Images:</b> PNG, JPG, JPEG, GIF, WebP, SVG, BMP, TIFF</li>
        <li><b>Videos:</b> MP4, AVI, MOV, MKV, WebM</li>
        <li><b>Audio:</b> MP3, WAV, FLAC, AAC</li>
        <li><b>Archives:</b> ZIP, RAR, 7Z, TAR, GZ</li>
        </ul>
        <b>Version Control:</b><br>
        Set <code>isVersionedFile: \"true\"</code> to enable version tracking. Versioned documents maintain full history of all changes.<br><br>
        <b>Response Headers:</b><br>
        <ul>
        <li><code>x-document-id</code>: Unique document identifier</li>
        <li><code>x-document-name</code>: Document name as stored</li>
        </ul>
        <b>Storage Backends:</b><br>
        Automatically routes to configured storage: Amazon S3, Azure Blob Storage, or Local filesystem.


        :param document_name: Display name for the document
        :param is_versioned_file: Enable version control for this document
        :param file: The file to upload (max 1GB)
        :param document_path: Virtual folder path for organization
        :param alternate_document_name: Alternative name for search/display
        :param permissions: Default permission level for shared access
        :param custom_metadata: JSON string of custom key-value metadata
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UploadDocumentRequest(
            document_name=document_name,
            document_path=document_path,
            alternate_document_name=alternate_document_name,
            permissions=permissions,
            custom_metadata=custom_metadata,
            is_versioned_file=is_versioned_file,
            file=utils.get_pydantic_model(file, models.UploadDocumentFile),
        )

        req = self._build_request_async(
            method="POST",
            path="/document/upload",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "multipart", models.UploadDocumentRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="uploadDocument",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["308", "400", "401", "413", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return models.UploadDocumentResponse(
                result=unmarshal_json_response(models.Document, http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "308", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["400", "401", "413", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def create_placeholder(
        self,
        *,
        document_name: str,
        document_path: str,
        extension: str,
        alternate_document_name: Optional[str] = None,
        permissions: Optional[models.CreateDocumentPlaceholderPermissions] = "owner",
        meta_data: Optional[
            Union[
                models.CreateDocumentPlaceholderMetaData,
                models.CreateDocumentPlaceholderMetaDataTypedDict,
            ]
        ] = None,
        is_versioned_file: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Document:
        r"""Create document placeholder

        Create a document metadata record without uploading file content. Used in conjunction with direct upload for large files.<br><br>
        <b>Overview:</b><br>
        This endpoint creates a document entry in the database without actual file content. The file is then uploaded directly to storage using the <code>/directUpload</code> endpoint.<br><br>
        <b>Direct Upload Flow:</b><br>
        <ol>
        <li>Call this endpoint to create document placeholder</li>
        <li>Receive document ID in response</li>
        <li>Call <code>/document/{documentId}/directUpload</code> to get presigned URL</li>
        <li>Upload file directly to presigned URL</li>
        <li>Document becomes accessible once upload completes</li>
        </ol>
        <b>Use Cases:</b><br>
        <ul>
        <li>Large file uploads (bypassing server)</li>
        <li>Client-side upload progress tracking</li>
        <li>Resumable uploads</li>
        <li>Reduced server memory usage</li>
        </ul>
        <b>Note:</b> Extension must be provided without the dot (e.g., \"pdf\" not \".pdf\").


        :param document_name: Display name for the document
        :param document_path: Virtual folder path
        :param extension: File extension WITHOUT dot
        :param alternate_document_name: Alternative name for search/display
        :param permissions:
        :param meta_data: Custom metadata key-value pairs
        :param is_versioned_file: Enable version control
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateDocumentPlaceholderRequest(
            document_name=document_name,
            alternate_document_name=alternate_document_name,
            document_path=document_path,
            permissions=permissions,
            meta_data=utils.get_pydantic_model(
                meta_data, Optional[models.CreateDocumentPlaceholderMetaData]
            ),
            is_versioned_file=is_versioned_file,
            extension=extension,
        )

        req = self._build_request(
            method="POST",
            path="/document/placeholder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateDocumentPlaceholderRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createDocumentPlaceholder",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Document, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def create_placeholder_async(
        self,
        *,
        document_name: str,
        document_path: str,
        extension: str,
        alternate_document_name: Optional[str] = None,
        permissions: Optional[models.CreateDocumentPlaceholderPermissions] = "owner",
        meta_data: Optional[
            Union[
                models.CreateDocumentPlaceholderMetaData,
                models.CreateDocumentPlaceholderMetaDataTypedDict,
            ]
        ] = None,
        is_versioned_file: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Document:
        r"""Create document placeholder

        Create a document metadata record without uploading file content. Used in conjunction with direct upload for large files.<br><br>
        <b>Overview:</b><br>
        This endpoint creates a document entry in the database without actual file content. The file is then uploaded directly to storage using the <code>/directUpload</code> endpoint.<br><br>
        <b>Direct Upload Flow:</b><br>
        <ol>
        <li>Call this endpoint to create document placeholder</li>
        <li>Receive document ID in response</li>
        <li>Call <code>/document/{documentId}/directUpload</code> to get presigned URL</li>
        <li>Upload file directly to presigned URL</li>
        <li>Document becomes accessible once upload completes</li>
        </ol>
        <b>Use Cases:</b><br>
        <ul>
        <li>Large file uploads (bypassing server)</li>
        <li>Client-side upload progress tracking</li>
        <li>Resumable uploads</li>
        <li>Reduced server memory usage</li>
        </ul>
        <b>Note:</b> Extension must be provided without the dot (e.g., \"pdf\" not \".pdf\").


        :param document_name: Display name for the document
        :param document_path: Virtual folder path
        :param extension: File extension WITHOUT dot
        :param alternate_document_name: Alternative name for search/display
        :param permissions:
        :param meta_data: Custom metadata key-value pairs
        :param is_versioned_file: Enable version control
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateDocumentPlaceholderRequest(
            document_name=document_name,
            alternate_document_name=alternate_document_name,
            document_path=document_path,
            permissions=permissions,
            meta_data=utils.get_pydantic_model(
                meta_data, Optional[models.CreateDocumentPlaceholderMetaData]
            ),
            is_versioned_file=is_versioned_file,
            extension=extension,
        )

        req = self._build_request_async(
            method="POST",
            path="/document/placeholder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateDocumentPlaceholderRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createDocumentPlaceholder",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Document, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_direct_url(
        self,
        *,
        document_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDirectUploadURLResponse:
        r"""Get direct upload URL

        Generate a presigned URL for direct client-to-storage upload, bypassing the server for large files.<br><br>
        <b>Overview:</b><br>
        This endpoint provides a presigned URL that allows clients to upload directly to storage (S3/Azure) without routing through the server. Essential for large file uploads.<br><br>
        <b>Direct Upload Flow:</b><br>
        <ol>
        <li>Create document placeholder with <code>/placeholder</code></li>
        <li>Call this endpoint with document ID</li>
        <li>Receive presigned URL and document ID</li>
        <li>Client uploads file directly to presigned URL (PUT request)</li>
        <li>Document becomes available once upload completes</li>
        </ol>
        <b>Benefits:</b><br>
        <ul>
        <li>No server memory consumption for large files</li>
        <li>Direct transfer to storage (faster)</li>
        <li>Client-side progress tracking</li>
        <li>Reduced server bandwidth</li>
        </ul>
        <b>URL Validity:</b><br>
        Presigned URLs typically expire after 1 hour. Upload must complete before expiration.<br><br>
        <b>Note:</b> Only available for S3 and Azure Blob storage. Local storage does not support direct upload.


        :param document_id: Document ID from placeholder creation
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDirectUploadURLRequest(
            document_id=document_id,
        )

        req = self._build_request(
            method="POST",
            path="/document/{documentId}/directUpload",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDirectUploadUrl",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetDirectUploadURLResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_direct_url_async(
        self,
        *,
        document_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDirectUploadURLResponse:
        r"""Get direct upload URL

        Generate a presigned URL for direct client-to-storage upload, bypassing the server for large files.<br><br>
        <b>Overview:</b><br>
        This endpoint provides a presigned URL that allows clients to upload directly to storage (S3/Azure) without routing through the server. Essential for large file uploads.<br><br>
        <b>Direct Upload Flow:</b><br>
        <ol>
        <li>Create document placeholder with <code>/placeholder</code></li>
        <li>Call this endpoint with document ID</li>
        <li>Receive presigned URL and document ID</li>
        <li>Client uploads file directly to presigned URL (PUT request)</li>
        <li>Document becomes available once upload completes</li>
        </ol>
        <b>Benefits:</b><br>
        <ul>
        <li>No server memory consumption for large files</li>
        <li>Direct transfer to storage (faster)</li>
        <li>Client-side progress tracking</li>
        <li>Reduced server bandwidth</li>
        </ul>
        <b>URL Validity:</b><br>
        Presigned URLs typically expire after 1 hour. Upload must complete before expiration.<br><br>
        <b>Note:</b> Only available for S3 and Azure Blob storage. Local storage does not support direct upload.


        :param document_id: Document ID from placeholder creation
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDirectUploadURLRequest(
            document_id=document_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/document/{documentId}/directUpload",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDirectUploadUrl",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetDirectUploadURLResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)
