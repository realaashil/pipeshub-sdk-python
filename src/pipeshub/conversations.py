"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from pipeshub import errors, models, utils
from pipeshub._hooks import HookContext
from pipeshub.types import OptionalNullable, UNSET
from pipeshub.utils import eventstreaming, get_security_from_env
from pipeshub.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union


class Conversations(BaseSDK):
    r"""AI-powered conversational chat management with citations and follow-up questions"""

    def create(
        self,
        *,
        query: str,
        record_ids: Optional[List[str]] = None,
        departments: Optional[List[str]] = None,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Create a new AI conversation

        Start a new conversation with PipesHub's AI assistant.<br><br>
        <b>Overview:</b><br>
        This endpoint creates a new conversation session and processes the initial query.
        The AI searches your organization's knowledge bases for relevant information and
        generates a response with citations to source documents.<br><br>
        <b>How It Works:</b><br>
        <ol>
        <li>Your query is analyzed and converted to semantic embeddings</li>
        <li>Relevant content is retrieved from indexed knowledge bases</li>
        <li>The AI generates a response using the retrieved context</li>
        <li>Citations link back to source documents for verification</li>
        <li>Follow-up questions are suggested based on the conversation</li>
        </ol>
        <b>Filtering Options:</b><br>
        <ul>
        <li><b>recordIds:</b> Limit search to specific documents</li>
        <li><b>filters.apps:</b> Search only specific connector apps</li>
        <li><b>filters.kb:</b> Search only specific knowledge bases</li>
        </ul>
        <b>Model Selection:</b><br>
        Use <code>modelKey</code> to select different AI models configured for your organization.
        Each model may have different capabilities, speed, and accuracy trade-offs.


        :param query: The user's question or prompt to start the conversation.
            Supports natural language queries of any complexity.

        :param record_ids: Limit the AI's knowledge scope to specific records/documents.
            When provided, only these records will be searched for context.

        :param departments: Filter by department IDs to scope the search
        :param filters:
        :param model_key: Identifier for the AI model configuration to use.
            Available models depend on organization settings.

        :param model_name: Display name of the AI model
        :param chat_mode: Chat mode affecting response behavior.
            Different modes optimize for different use cases.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateConversationRequest(
            query=query,
            record_ids=record_ids,
            departments=departments,
            filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
            model_key=model_key,
            model_name=model_name,
            chat_mode=chat_mode,
        )

        req = self._build_request(
            method="POST",
            path="/conversations/create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateConversationRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "502", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["502", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        query: str,
        record_ids: Optional[List[str]] = None,
        departments: Optional[List[str]] = None,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Create a new AI conversation

        Start a new conversation with PipesHub's AI assistant.<br><br>
        <b>Overview:</b><br>
        This endpoint creates a new conversation session and processes the initial query.
        The AI searches your organization's knowledge bases for relevant information and
        generates a response with citations to source documents.<br><br>
        <b>How It Works:</b><br>
        <ol>
        <li>Your query is analyzed and converted to semantic embeddings</li>
        <li>Relevant content is retrieved from indexed knowledge bases</li>
        <li>The AI generates a response using the retrieved context</li>
        <li>Citations link back to source documents for verification</li>
        <li>Follow-up questions are suggested based on the conversation</li>
        </ol>
        <b>Filtering Options:</b><br>
        <ul>
        <li><b>recordIds:</b> Limit search to specific documents</li>
        <li><b>filters.apps:</b> Search only specific connector apps</li>
        <li><b>filters.kb:</b> Search only specific knowledge bases</li>
        </ul>
        <b>Model Selection:</b><br>
        Use <code>modelKey</code> to select different AI models configured for your organization.
        Each model may have different capabilities, speed, and accuracy trade-offs.


        :param query: The user's question or prompt to start the conversation.
            Supports natural language queries of any complexity.

        :param record_ids: Limit the AI's knowledge scope to specific records/documents.
            When provided, only these records will be searched for context.

        :param departments: Filter by department IDs to scope the search
        :param filters:
        :param model_key: Identifier for the AI model configuration to use.
            Available models depend on organization settings.

        :param model_name: Display name of the AI model
        :param chat_mode: Chat mode affecting response behavior.
            Different modes optimize for different use cases.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateConversationRequest(
            query=query,
            record_ids=record_ids,
            departments=departments,
            filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
            model_key=model_key,
            model_name=model_name,
            chat_mode=chat_mode,
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateConversationRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "502", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["502", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def create_with_streaming(
        self,
        *,
        query: str,
        record_ids: Optional[List[str]] = None,
        departments: Optional[List[str]] = None,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> eventstreaming.EventStream[models.SSEEvent]:
        r"""Create conversation with streaming response

        Start a new conversation with real-time streaming response using Server-Sent Events (SSE).<br><br>
        <b>Overview:</b><br>
        This endpoint works like <code>/conversations/create</code> but streams the AI response
        in real-time as it's generated, providing a more interactive user experience.<br><br>
        <b>SSE Event Types:</b><br>
        <ul>
        <li><code>connected</code> - Connection established, processing started</li>
        <li><code>chunk</code> - Partial response text (stream these to show typing effect)</li>
        <li><code>citation</code> - Citation reference found during generation</li>
        <li><code>complete</code> - Final message with full response, citations, and follow-up questions</li>
        <li><code>error</code> - Error occurred during processing</li>
        </ul>
        <b>Client Implementation:</b><br>
        <code>
        const eventSource = new EventSource('/conversations/stream');<br>
        eventSource.onmessage = (event) => {<br>
        &nbsp;&nbsp;const data = JSON.parse(event.data);<br>
        &nbsp;&nbsp;// Handle different event types<br>
        };
        </code><br><br>
        <b>Error Handling:</b><br>
        If an error occurs mid-stream, an <code>error</code> event is sent and the stream closes.
        The conversation is marked as FAILED with the error reason stored.


        :param query: The user's question or prompt to start the conversation.
            Supports natural language queries of any complexity.

        :param record_ids: Limit the AI's knowledge scope to specific records/documents.
            When provided, only these records will be searched for context.

        :param departments: Filter by department IDs to scope the search
        :param filters:
        :param model_key: Identifier for the AI model configuration to use.
            Available models depend on organization settings.

        :param model_name: Display name of the AI model
        :param chat_mode: Chat mode affecting response behavior.
            Different modes optimize for different use cases.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateConversationRequest(
            query=query,
            record_ids=record_ids,
            departments=departments,
            filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
            model_key=model_key,
            model_name=model_name,
            chat_mode=chat_mode,
        )

        req = self._build_request(
            method="POST",
            path="/conversations/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateConversationRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="streamChat",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "502", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStream(
                http_res,
                lambda raw: utils.unmarshal_json(raw, models.SSEEvent),
                client_ref=self,
            )
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["502", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = utils.stream_to_text(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def create_with_streaming_async(
        self,
        *,
        query: str,
        record_ids: Optional[List[str]] = None,
        departments: Optional[List[str]] = None,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> eventstreaming.EventStreamAsync[models.SSEEvent]:
        r"""Create conversation with streaming response

        Start a new conversation with real-time streaming response using Server-Sent Events (SSE).<br><br>
        <b>Overview:</b><br>
        This endpoint works like <code>/conversations/create</code> but streams the AI response
        in real-time as it's generated, providing a more interactive user experience.<br><br>
        <b>SSE Event Types:</b><br>
        <ul>
        <li><code>connected</code> - Connection established, processing started</li>
        <li><code>chunk</code> - Partial response text (stream these to show typing effect)</li>
        <li><code>citation</code> - Citation reference found during generation</li>
        <li><code>complete</code> - Final message with full response, citations, and follow-up questions</li>
        <li><code>error</code> - Error occurred during processing</li>
        </ul>
        <b>Client Implementation:</b><br>
        <code>
        const eventSource = new EventSource('/conversations/stream');<br>
        eventSource.onmessage = (event) => {<br>
        &nbsp;&nbsp;const data = JSON.parse(event.data);<br>
        &nbsp;&nbsp;// Handle different event types<br>
        };
        </code><br><br>
        <b>Error Handling:</b><br>
        If an error occurs mid-stream, an <code>error</code> event is sent and the stream closes.
        The conversation is marked as FAILED with the error reason stored.


        :param query: The user's question or prompt to start the conversation.
            Supports natural language queries of any complexity.

        :param record_ids: Limit the AI's knowledge scope to specific records/documents.
            When provided, only these records will be searched for context.

        :param departments: Filter by department IDs to scope the search
        :param filters:
        :param model_key: Identifier for the AI model configuration to use.
            Available models depend on organization settings.

        :param model_name: Display name of the AI model
        :param chat_mode: Chat mode affecting response behavior.
            Different modes optimize for different use cases.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateConversationRequest(
            query=query,
            record_ids=record_ids,
            departments=departments,
            filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
            model_key=model_key,
            model_name=model_name,
            chat_mode=chat_mode,
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateConversationRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="streamChat",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "502", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStreamAsync(
                http_res,
                lambda raw: utils.unmarshal_json(raw, models.SSEEvent),
                client_ref=self,
            )
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["502", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def list(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Conversation]:
        r"""List all conversations

        Retrieve all conversations for the authenticated user.<br><br>
        <b>Overview:</b><br>
        Returns a list of all conversations owned by or shared with the current user.
        Conversations are returned with their messages, status, and metadata.<br><br>
        <b>Filtering:</b><br>
        <ul>
        <li>Only non-archived conversations are returned by default</li>
        <li>Use <code>/conversations/show/archives</code> for archived conversations</li>
        </ul>
        <b>Sorting:</b><br>
        Conversations are sorted by last activity timestamp (most recent first).


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/conversations",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllConversations",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Conversation], http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Conversation]:
        r"""List all conversations

        Retrieve all conversations for the authenticated user.<br><br>
        <b>Overview:</b><br>
        Returns a list of all conversations owned by or shared with the current user.
        Conversations are returned with their messages, status, and metadata.<br><br>
        <b>Filtering:</b><br>
        <ul>
        <li>Only non-archived conversations are returned by default</li>
        <li>Use <code>/conversations/show/archives</code> for archived conversations</li>
        </ul>
        <b>Sorting:</b><br>
        Conversations are sorted by last activity timestamp (most recent first).


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/conversations",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllConversations",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Conversation], http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def list_archived(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Conversation]:
        r"""List archived conversations

        Retrieve all archived conversations for the authenticated user.<br><br>
        <b>Overview:</b><br>
        Archived conversations are hidden from the main list but preserved for reference.
        This endpoint returns only conversations where <code>isArchived: true</code>.<br><br>
        <b>Unarchiving:</b><br>
        Use <code>PATCH /conversations/{id}/unarchive</code> to restore a conversation
        to the active list.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/conversations/show/archives",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getArchivedConversations",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Conversation], http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def list_archived_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Conversation]:
        r"""List archived conversations

        Retrieve all archived conversations for the authenticated user.<br><br>
        <b>Overview:</b><br>
        Archived conversations are hidden from the main list but preserved for reference.
        This endpoint returns only conversations where <code>isArchived: true</code>.<br><br>
        <b>Unarchiving:</b><br>
        Use <code>PATCH /conversations/{id}/unarchive</code> to restore a conversation
        to the active list.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/conversations/show/archives",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getArchivedConversations",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Conversation], http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_by_id(
        self,
        *,
        conversation_id: str,
        page: Optional[int] = 1,
        limit: Optional[int] = 10,
        sort_by: Optional[str] = "createdAt",
        sort_order: Optional[models.GetConversationByIDSortOrder] = "desc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetConversationByIDResponse:
        r"""Get conversation by ID

        Retrieve a specific conversation with its full message history.<br><br>
        <b>Overview:</b><br>
        Returns the complete conversation including all messages, citations,
        feedback, and metadata. Messages can be paginated for long conversations.<br><br>
        <b>Message Pagination:</b><br>
        For conversations with many messages, use pagination parameters:
        <ul>
        <li><code>page</code>: Page number (default: 1)</li>
        <li><code>limit</code>: Messages per page (default: 10)</li>
        <li><code>sortBy</code>: Sort field (default: createdAt)</li>
        <li><code>sortOrder</code>: 'asc' or 'desc' (default: desc)</li>
        </ul>
        <b>Access Control:</b><br>
        Users can access conversations they own or that have been shared with them.


        :param conversation_id: Unique conversation identifier
        :param page: Page number for message pagination
        :param limit: Number of messages per page
        :param sort_by: Field to sort messages by
        :param sort_order: Sort direction
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetConversationByIDRequest(
            conversation_id=conversation_id,
            page=page,
            limit=limit,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request(
            method="GET",
            path="/conversations/{conversationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getConversationById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetConversationByIDResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_by_id_async(
        self,
        *,
        conversation_id: str,
        page: Optional[int] = 1,
        limit: Optional[int] = 10,
        sort_by: Optional[str] = "createdAt",
        sort_order: Optional[models.GetConversationByIDSortOrder] = "desc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetConversationByIDResponse:
        r"""Get conversation by ID

        Retrieve a specific conversation with its full message history.<br><br>
        <b>Overview:</b><br>
        Returns the complete conversation including all messages, citations,
        feedback, and metadata. Messages can be paginated for long conversations.<br><br>
        <b>Message Pagination:</b><br>
        For conversations with many messages, use pagination parameters:
        <ul>
        <li><code>page</code>: Page number (default: 1)</li>
        <li><code>limit</code>: Messages per page (default: 10)</li>
        <li><code>sortBy</code>: Sort field (default: createdAt)</li>
        <li><code>sortOrder</code>: 'asc' or 'desc' (default: desc)</li>
        </ul>
        <b>Access Control:</b><br>
        Users can access conversations they own or that have been shared with them.


        :param conversation_id: Unique conversation identifier
        :param page: Page number for message pagination
        :param limit: Number of messages per page
        :param sort_by: Field to sort messages by
        :param sort_order: Sort direction
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetConversationByIDRequest(
            conversation_id=conversation_id,
            page=page,
            limit=limit,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request_async(
            method="GET",
            path="/conversations/{conversationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getConversationById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetConversationByIDResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        conversation_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteConversationByIDResponse:
        r"""Delete conversation

        Delete a conversation by its ID.<br><br>
        <b>Overview:</b><br>
        Performs a soft delete by setting <code>isDeleted: true</code>.
        The conversation is removed from listings but preserved in the database.<br><br>
        <b>Permissions:</b><br>
        Only the conversation owner (initiator) can delete it.
        Shared users cannot delete conversations.


        :param conversation_id: Unique conversation identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteConversationByIDRequest(
            conversation_id=conversation_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/conversations/{conversationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteConversationById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DeleteConversationByIDResponse, http_res
            )
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        conversation_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteConversationByIDResponse:
        r"""Delete conversation

        Delete a conversation by its ID.<br><br>
        <b>Overview:</b><br>
        Performs a soft delete by setting <code>isDeleted: true</code>.
        The conversation is removed from listings but preserved in the database.<br><br>
        <b>Permissions:</b><br>
        Only the conversation owner (initiator) can delete it.
        Shared users cannot delete conversations.


        :param conversation_id: Unique conversation identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteConversationByIDRequest(
            conversation_id=conversation_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/conversations/{conversationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteConversationById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DeleteConversationByIDResponse, http_res
            )
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def add_message(
        self,
        *,
        conversation_id: str,
        query: str,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Add message to conversation

        Add a follow-up message to an existing conversation.<br><br>
        <b>Overview:</b><br>
        Continues an existing conversation by adding a new user query.
        The AI maintains context from previous messages when generating the response.<br><br>
        <b>Context Handling:</b><br>
        <ul>
        <li>Previous messages provide context for the new query</li>
        <li>Citations from earlier messages may be referenced</li>
        <li>The AI can refer back to previous topics discussed</li>
        </ul>
        <b>Model Override:</b><br>
        You can specify a different model for this message using <code>modelKey</code>.
        This allows switching models mid-conversation if needed.


        :param conversation_id: Unique conversation identifier
        :param query: The follow-up question or message content
        :param filters:
        :param model_key: Override the model for this specific message
        :param model_name: Display name of the model
        :param chat_mode: Chat mode for this message
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddMessageRequestRequest(
            conversation_id=conversation_id,
            body=models.AddMessageRequest(
                query=query,
                filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
                model_key=model_key,
                model_name=model_name,
                chat_mode=chat_mode,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/conversations/{conversationId}/messages",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.AddMessageRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addMessage",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def add_message_async(
        self,
        *,
        conversation_id: str,
        query: str,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Add message to conversation

        Add a follow-up message to an existing conversation.<br><br>
        <b>Overview:</b><br>
        Continues an existing conversation by adding a new user query.
        The AI maintains context from previous messages when generating the response.<br><br>
        <b>Context Handling:</b><br>
        <ul>
        <li>Previous messages provide context for the new query</li>
        <li>Citations from earlier messages may be referenced</li>
        <li>The AI can refer back to previous topics discussed</li>
        </ul>
        <b>Model Override:</b><br>
        You can specify a different model for this message using <code>modelKey</code>.
        This allows switching models mid-conversation if needed.


        :param conversation_id: Unique conversation identifier
        :param query: The follow-up question or message content
        :param filters:
        :param model_key: Override the model for this specific message
        :param model_name: Display name of the model
        :param chat_mode: Chat mode for this message
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddMessageRequestRequest(
            conversation_id=conversation_id,
            body=models.AddMessageRequest(
                query=query,
                filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
                model_key=model_key,
                model_name=model_name,
                chat_mode=chat_mode,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/{conversationId}/messages",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.AddMessageRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addMessage",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def add_message_stream(
        self,
        *,
        conversation_id: str,
        query: str,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> eventstreaming.EventStream[models.SSEEvent]:
        r"""Add message with streaming response

        Add a follow-up message to an existing conversation with real-time SSE streaming.<br><br>
        <b>Overview:</b><br>
        Same as <code>POST /conversations/{id}/messages</code> but with streaming response.
        Provides real-time feedback as the AI generates its response.<br><br>
        <b>SSE Events:</b><br>
        See <code>/conversations/stream</code> for event type documentation.


        :param conversation_id:
        :param query: The follow-up question or message content
        :param filters:
        :param model_key: Override the model for this specific message
        :param model_name: Display name of the model
        :param chat_mode: Chat mode for this message
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddMessageStreamRequest(
            conversation_id=conversation_id,
            body=models.AddMessageRequest(
                query=query,
                filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
                model_key=model_key,
                model_name=model_name,
                chat_mode=chat_mode,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/conversations/{conversationId}/messages/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.AddMessageRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addMessageStream",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStream(
                http_res,
                lambda raw: utils.unmarshal_json(raw, models.SSEEvent),
                client_ref=self,
            )
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = utils.stream_to_text(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def add_message_stream_async(
        self,
        *,
        conversation_id: str,
        query: str,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> eventstreaming.EventStreamAsync[models.SSEEvent]:
        r"""Add message with streaming response

        Add a follow-up message to an existing conversation with real-time SSE streaming.<br><br>
        <b>Overview:</b><br>
        Same as <code>POST /conversations/{id}/messages</code> but with streaming response.
        Provides real-time feedback as the AI generates its response.<br><br>
        <b>SSE Events:</b><br>
        See <code>/conversations/stream</code> for event type documentation.


        :param conversation_id:
        :param query: The follow-up question or message content
        :param filters:
        :param model_key: Override the model for this specific message
        :param model_name: Display name of the model
        :param chat_mode: Chat mode for this message
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddMessageStreamRequest(
            conversation_id=conversation_id,
            body=models.AddMessageRequest(
                query=query,
                filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
                model_key=model_key,
                model_name=model_name,
                chat_mode=chat_mode,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/{conversationId}/messages/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.AddMessageRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addMessageStream",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStreamAsync(
                http_res,
                lambda raw: utils.unmarshal_json(raw, models.SSEEvent),
                client_ref=self,
            )
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def share(
        self,
        *,
        conversation_id: str,
        user_ids: List[str],
        access_level: Optional[models.ShareRequestAccessLevel] = "read",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Share conversation with users

        Share a conversation with other users in your organization.<br><br>
        <b>Overview:</b><br>
        Allows the conversation owner to grant access to other users.
        Shared users can view the conversation and optionally add messages.<br><br>
        <b>Access Levels:</b><br>
        <ul>
        <li><code>read</code> - Can view conversation and messages (default)</li>
        <li><code>write</code> - Can view and add new messages</li>
        </ul>
        <b>Permissions:</b><br>
        Only the conversation initiator (owner) can share. Users must belong
        to the same organization.


        :param conversation_id:
        :param user_ids: IDs of users to share with
        :param access_level: Permission level for shared users:
            <ul>
            <li><code>read</code> - Can view only</li>
            <li><code>write</code> - Can add messages</li>
            </ul>

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ShareConversationRequest(
            conversation_id=conversation_id,
            body=models.ShareRequest(
                user_ids=user_ids,
                access_level=access_level,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/conversations/{conversationId}/share",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.ShareRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="shareConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def share_async(
        self,
        *,
        conversation_id: str,
        user_ids: List[str],
        access_level: Optional[models.ShareRequestAccessLevel] = "read",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Share conversation with users

        Share a conversation with other users in your organization.<br><br>
        <b>Overview:</b><br>
        Allows the conversation owner to grant access to other users.
        Shared users can view the conversation and optionally add messages.<br><br>
        <b>Access Levels:</b><br>
        <ul>
        <li><code>read</code> - Can view conversation and messages (default)</li>
        <li><code>write</code> - Can view and add new messages</li>
        </ul>
        <b>Permissions:</b><br>
        Only the conversation initiator (owner) can share. Users must belong
        to the same organization.


        :param conversation_id:
        :param user_ids: IDs of users to share with
        :param access_level: Permission level for shared users:
            <ul>
            <li><code>read</code> - Can view only</li>
            <li><code>write</code> - Can add messages</li>
            </ul>

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ShareConversationRequest(
            conversation_id=conversation_id,
            body=models.ShareRequest(
                user_ids=user_ids,
                access_level=access_level,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/{conversationId}/share",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.ShareRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="shareConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def unshare(
        self,
        *,
        conversation_id: str,
        user_ids: List[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Revoke conversation access

        Remove sharing access from users.<br><br>
        <b>Overview:</b><br>
        Removes specified users from the conversation's sharedWith list.
        Those users will no longer be able to access the conversation.<br><br>
        <b>Permissions:</b><br>
        Only the conversation owner can revoke access.


        :param conversation_id:
        :param user_ids: User IDs to remove access from
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UnshareConversationRequest(
            conversation_id=conversation_id,
            body=models.UnshareConversationRequestBody(
                user_ids=user_ids,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/conversations/{conversationId}/unshare",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UnshareConversationRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="unshareConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def unshare_async(
        self,
        *,
        conversation_id: str,
        user_ids: List[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Revoke conversation access

        Remove sharing access from users.<br><br>
        <b>Overview:</b><br>
        Removes specified users from the conversation's sharedWith list.
        Those users will no longer be able to access the conversation.<br><br>
        <b>Permissions:</b><br>
        Only the conversation owner can revoke access.


        :param conversation_id:
        :param user_ids: User IDs to remove access from
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UnshareConversationRequest(
            conversation_id=conversation_id,
            body=models.UnshareConversationRequestBody(
                user_ids=user_ids,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/{conversationId}/unshare",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UnshareConversationRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="unshareConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update_title(
        self,
        *,
        conversation_id: str,
        title: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Update conversation title

        Update the title of a conversation.<br><br>
        <b>Overview:</b><br>
        Conversation titles are auto-generated from the first query by default.
        Use this endpoint to set a custom, more descriptive title.<br><br>
        <b>Title Limits:</b><br>
        <ul>
        <li>Minimum: 1 character</li>
        <li>Maximum: 200 characters</li>
        </ul>


        :param conversation_id:
        :param title: New conversation title
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateConversationTitleRequest(
            conversation_id=conversation_id,
            body=models.UpdateConversationTitleRequestBody(
                title=title,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/conversations/{conversationId}/title",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UpdateConversationTitleRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateConversationTitle",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_title_async(
        self,
        *,
        conversation_id: str,
        title: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Update conversation title

        Update the title of a conversation.<br><br>
        <b>Overview:</b><br>
        Conversation titles are auto-generated from the first query by default.
        Use this endpoint to set a custom, more descriptive title.<br><br>
        <b>Title Limits:</b><br>
        <ul>
        <li>Minimum: 1 character</li>
        <li>Maximum: 200 characters</li>
        </ul>


        :param conversation_id:
        :param title: New conversation title
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateConversationTitleRequest(
            conversation_id=conversation_id,
            body=models.UpdateConversationTitleRequestBody(
                title=title,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/conversations/{conversationId}/title",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UpdateConversationTitleRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateConversationTitle",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def archive(
        self,
        *,
        conversation_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Archive conversation

        Archive a conversation to hide it from the main list.<br><br>
        <b>Overview:</b><br>
        Archived conversations are preserved but hidden from the default conversation list.
        Use archiving to clean up your workspace without permanently deleting conversations.<br><br>
        <b>Retrieval:</b><br>
        View archived conversations using <code>GET /conversations/show/archives</code>.


        :param conversation_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ArchiveConversationRequest(
            conversation_id=conversation_id,
        )

        req = self._build_request(
            method="PATCH",
            path="/conversations/{conversationId}/archive",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="archiveConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def archive_async(
        self,
        *,
        conversation_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Archive conversation

        Archive a conversation to hide it from the main list.<br><br>
        <b>Overview:</b><br>
        Archived conversations are preserved but hidden from the default conversation list.
        Use archiving to clean up your workspace without permanently deleting conversations.<br><br>
        <b>Retrieval:</b><br>
        View archived conversations using <code>GET /conversations/show/archives</code>.


        :param conversation_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ArchiveConversationRequest(
            conversation_id=conversation_id,
        )

        req = self._build_request_async(
            method="PATCH",
            path="/conversations/{conversationId}/archive",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="archiveConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def unarchive(
        self,
        *,
        conversation_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Unarchive conversation

        Restore an archived conversation to the active list.<br><br>
        <b>Overview:</b><br>
        Removes the archived flag, making the conversation visible in the main list again.


        :param conversation_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UnarchiveConversationRequest(
            conversation_id=conversation_id,
        )

        req = self._build_request(
            method="PATCH",
            path="/conversations/{conversationId}/unarchive",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="unarchiveConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def unarchive_async(
        self,
        *,
        conversation_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Unarchive conversation

        Restore an archived conversation to the active list.<br><br>
        <b>Overview:</b><br>
        Removes the archived flag, making the conversation visible in the main list again.


        :param conversation_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UnarchiveConversationRequest(
            conversation_id=conversation_id,
        )

        req = self._build_request_async(
            method="PATCH",
            path="/conversations/{conversationId}/unarchive",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="unarchiveConversation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def regenerate(
        self,
        *,
        conversation_id: str,
        message_id: str,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Regenerate AI response

        Regenerate the AI response for a specific message.<br><br>
        <b>Overview:</b><br>
        If you're not satisfied with an AI response, use this endpoint to generate
        a new answer. The AI will re-process the original query and may produce
        a different response.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Response was incomplete or unclear</li>
        <li>Want to try a different AI model</li>
        <li>New documents have been indexed since original response</li>
        </ul>
        <b>Model Override:</b><br>
        Specify <code>modelKey</code> to use a different model for regeneration.


        :param conversation_id:
        :param message_id: ID of the message to regenerate response for
        :param filters:
        :param model_key: Override model for regeneration
        :param model_name:
        :param chat_mode:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RegenerateAnswerRequest(
            conversation_id=conversation_id,
            message_id=message_id,
            body=models.RegenerateAnswerRequestBody(
                filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
                model_key=model_key,
                model_name=model_name,
                chat_mode=chat_mode,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/conversations/{conversationId}/message/{messageId}/regenerate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                True,
                "json",
                Optional[models.RegenerateAnswerRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="regenerateAnswer",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def regenerate_async(
        self,
        *,
        conversation_id: str,
        message_id: str,
        filters: Optional[Union[models.Filters, models.FiltersTypedDict]] = None,
        model_key: Optional[str] = None,
        model_name: Optional[str] = None,
        chat_mode: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Regenerate AI response

        Regenerate the AI response for a specific message.<br><br>
        <b>Overview:</b><br>
        If you're not satisfied with an AI response, use this endpoint to generate
        a new answer. The AI will re-process the original query and may produce
        a different response.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Response was incomplete or unclear</li>
        <li>Want to try a different AI model</li>
        <li>New documents have been indexed since original response</li>
        </ul>
        <b>Model Override:</b><br>
        Specify <code>modelKey</code> to use a different model for regeneration.


        :param conversation_id:
        :param message_id: ID of the message to regenerate response for
        :param filters:
        :param model_key: Override model for regeneration
        :param model_name:
        :param chat_mode:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RegenerateAnswerRequest(
            conversation_id=conversation_id,
            message_id=message_id,
            body=models.RegenerateAnswerRequestBody(
                filters=utils.get_pydantic_model(filters, Optional[models.Filters]),
                model_key=model_key,
                model_name=model_name,
                chat_mode=chat_mode,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/{conversationId}/message/{messageId}/regenerate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                True,
                "json",
                Optional[models.RegenerateAnswerRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="regenerateAnswer",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def submit_feedback(
        self,
        *,
        conversation_id: str,
        message_id: str,
        is_helpful: Optional[bool] = None,
        ratings: Optional[Union[models.Ratings, models.RatingsTypedDict]] = None,
        categories: Optional[List[models.Category]] = None,
        comments: Optional[Union[models.Comments, models.CommentsTypedDict]] = None,
        citation_feedback: Optional[
            Union[List[models.CitationFeedback], List[models.CitationFeedbackTypedDict]]
        ] = None,
        follow_up_questions_helpful: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Submit feedback on AI response

        Provide feedback on an AI-generated response.<br><br>
        <b>Overview:</b><br>
        Feedback helps improve AI response quality over time. You can rate
        various aspects of the response and provide detailed comments.<br><br>
        <b>Feedback Options:</b><br>
        <ul>
        <li><b>isHelpful:</b> Overall thumbs up/down</li>
        <li><b>ratings:</b> 1-5 scale for accuracy, relevance, completeness, clarity</li>
        <li><b>categories:</b> Issue categories (incorrect info, too verbose, etc.)</li>
        <li><b>comments:</b> Free-text positive/negative feedback and suggestions</li>
        <li><b>citationFeedback:</b> Rate individual citations</li>
        </ul>
        <b>Restrictions:</b><br>
        Feedback can only be submitted on <code>bot_response</code> messages,
        not on user queries or system messages.


        :param conversation_id:
        :param message_id:
        :param is_helpful: Overall helpfulness rating
        :param ratings:
        :param categories: Categories of issues identified
        :param comments:
        :param citation_feedback: Feedback on individual citations
        :param follow_up_questions_helpful: Were the suggested follow-up questions helpful
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateMessageFeedbackRequest(
            conversation_id=conversation_id,
            message_id=message_id,
            body=models.MessageFeedback(
                is_helpful=is_helpful,
                ratings=utils.get_pydantic_model(ratings, Optional[models.Ratings]),
                categories=categories,
                comments=utils.get_pydantic_model(comments, Optional[models.Comments]),
                citation_feedback=utils.get_pydantic_model(
                    citation_feedback, Optional[List[models.CitationFeedback]]
                ),
                follow_up_questions_helpful=follow_up_questions_helpful,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/conversations/{conversationId}/message/{messageId}/feedback",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.MessageFeedback
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateMessageFeedback",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def submit_feedback_async(
        self,
        *,
        conversation_id: str,
        message_id: str,
        is_helpful: Optional[bool] = None,
        ratings: Optional[Union[models.Ratings, models.RatingsTypedDict]] = None,
        categories: Optional[List[models.Category]] = None,
        comments: Optional[Union[models.Comments, models.CommentsTypedDict]] = None,
        citation_feedback: Optional[
            Union[List[models.CitationFeedback], List[models.CitationFeedbackTypedDict]]
        ] = None,
        follow_up_questions_helpful: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Conversation:
        r"""Submit feedback on AI response

        Provide feedback on an AI-generated response.<br><br>
        <b>Overview:</b><br>
        Feedback helps improve AI response quality over time. You can rate
        various aspects of the response and provide detailed comments.<br><br>
        <b>Feedback Options:</b><br>
        <ul>
        <li><b>isHelpful:</b> Overall thumbs up/down</li>
        <li><b>ratings:</b> 1-5 scale for accuracy, relevance, completeness, clarity</li>
        <li><b>categories:</b> Issue categories (incorrect info, too verbose, etc.)</li>
        <li><b>comments:</b> Free-text positive/negative feedback and suggestions</li>
        <li><b>citationFeedback:</b> Rate individual citations</li>
        </ul>
        <b>Restrictions:</b><br>
        Feedback can only be submitted on <code>bot_response</code> messages,
        not on user queries or system messages.


        :param conversation_id:
        :param message_id:
        :param is_helpful: Overall helpfulness rating
        :param ratings:
        :param categories: Categories of issues identified
        :param comments:
        :param citation_feedback: Feedback on individual citations
        :param follow_up_questions_helpful: Were the suggested follow-up questions helpful
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateMessageFeedbackRequest(
            conversation_id=conversation_id,
            message_id=message_id,
            body=models.MessageFeedback(
                is_helpful=is_helpful,
                ratings=utils.get_pydantic_model(ratings, Optional[models.Ratings]),
                categories=categories,
                comments=utils.get_pydantic_model(comments, Optional[models.Comments]),
                citation_feedback=utils.get_pydantic_model(
                    citation_feedback, Optional[List[models.CitationFeedback]]
                ),
                follow_up_questions_helpful=follow_up_questions_helpful,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/conversations/{conversationId}/message/{messageId}/feedback",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.MessageFeedback
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateMessageFeedback",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Conversation, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)
