"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from pipeshub import errors, models, utils
from pipeshub._hooks import HookContext
from pipeshub.types import OptionalNullable, UNSET
from pipeshub.utils import get_security_from_env
from pipeshub.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, List, Mapping, Optional, Union


class EmailOperations(BaseSDK):
    def send(
        self,
        *,
        security: Union[models.SendEmailSecurity, models.SendEmailSecurityTypedDict],
        email_template_type: models.EmailTemplateType,
        send_email_to: List[str],
        product_name: Optional[str] = None,
        is_auto_email: Optional[bool] = False,
        from_email_domain: Optional[str] = None,
        subject: Optional[str] = None,
        template_data: Optional[
            Union[models.TemplateData, models.TemplateDataTypedDict]
        ] = None,
        send_cc_to: Optional[List[str]] = None,
        attachments: Optional[
            Union[List[models.Attachment], List[models.AttachmentTypedDict]]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SendEmailResponse:
        r"""Send a transactional email

        Send a transactional email using the configured SMTP server with a pre-defined template.<br><br>

        <b>Overview:</b><br>
        This is an internal service endpoint used by other PipesHub services to send transactional emails.
        It uses Handlebars templates to generate HTML emails with dynamic content. All sent emails are
        logged to the database for audit purposes.<br><br>

        <b>Authentication:</b><br>
        Requires a scoped token with <code>mail:send</code> scope. This endpoint is not accessible
        with regular user JWT tokens - it is designed for service-to-service communication only.<br><br>

        <b>Available Templates:</b><br>
        <ul>
        <li><b>loginWithOTP</b> - Send OTP code for user authentication. Requires: <code>name</code>, <code>otp</code></li>
        <li><b>resetPassword</b> - Password reset link. Requires: <code>name</code>, <code>link</code></li>
        <li><b>accountCreation</b> - Welcome email for new organizations. Requires: <code>orgName</code>, <code>link</code></li>
        <li><b>appuserInvite</b> - Invitation to join organization. Requires: <code>invitee</code>, <code>orgName</code>, <code>link</code></li>
        <li><b>suspiciousLoginAttempt</b> - Security alert. Requires: <code>link</code></li>
        </ul>

        <b>Email Delivery Flow:</b><br>
        <ol>
        <li>Validate SMTP configuration exists (middleware check)</li>
        <li>Validate scoped token has <code>mail:send</code> scope</li>
        <li>Select and compile Handlebars template with provided data</li>
        <li>Send email via nodemailer using SMTP configuration</li>
        <li>Log email metadata to MongoDB (subject, from, to, cc, templateType)</li>
        </ol>

        <b>Important Notes:</b><br>
        <ul>
        <li>The \"From\" address is always taken from SMTP config, not the request body</li>
        <li>Failed email sends return 500 with error details</li>
        <li>Template mismatches throw \"Unknown Template\" error</li>
        <li>SMTP must be configured before using this endpoint</li>
        </ul>

        <b>Related Endpoints:</b><br>
        <ul>
        <li><code>POST /configurationManager/smtpConfig</code> - Configure SMTP server</li>
        <li><code>POST /mail/updateSmtpConfig</code> - Reload SMTP configuration at runtime</li>
        </ul>


        :param security:
        :param email_template_type: Type of email template to use. Each template has specific `templateData` requirements:
            - `loginWithOTP`: OTP authentication email
            - `resetPassword`: Password reset link email
            - `accountCreation`: Welcome email for new organizations
            - `appuserInvite`: Invitation email to join an organization
            - `suspiciousLoginAttempt`: Security alert for multiple failed OTP attempts

        :param send_email_to: List of recipient email addresses (at least one required)
        :param product_name: Name of the product sending the email (used in templates for branding)
        :param is_auto_email: Flag indicating if this is an automated system email (for tracking/filtering purposes)
        :param from_email_domain: Sender email address for audit logging. **Note:** The actual \"From\" address used
            in the email is taken from the SMTP server configuration (`smtpConfig.fromEmail`),
            not this field. This field is stored in the database for record-keeping.

        :param subject: Email subject line
        :param template_data: Dynamic data to populate the email template. Required fields depend on <code>emailTemplateType</code>.<br><br>
            <b>Template Data Requirements:</b><br>
            <ul>
            <li><b>loginWithOTP:</b> See <code>LoginWithOTPTemplateData</code> - requires <code>name</code>, <code>otp</code></li>
            <li><b>resetPassword:</b> See <code>ResetPasswordTemplateData</code> - requires <code>name</code>, <code>link</code></li>
            <li><b>accountCreation:</b> See <code>AccountCreationTemplateData</code> - requires <code>orgName</code>, <code>link</code></li>
            <li><b>appuserInvite:</b> See <code>AppUserInviteTemplateData</code> - requires <code>invitee</code>, <code>orgName</code>, <code>link</code></li>
            <li><b>suspiciousLoginAttempt:</b> See <code>SuspiciousLoginTemplateData</code> - requires <code>link</code></li>
            </ul>

        :param send_cc_to: Optional list of CC recipient email addresses
        :param attachments: Optional email attachments (uses nodemailer attachment format)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.MailBody(
            product_name=product_name,
            email_template_type=email_template_type,
            is_auto_email=is_auto_email,
            from_email_domain=from_email_domain,
            send_email_to=send_email_to,
            subject=subject,
            template_data=utils.get_pydantic_model(
                template_data, Optional[models.TemplateData]
            ),
            send_cc_to=send_cc_to,
            attachments=utils.get_pydantic_model(
                attachments, Optional[List[models.Attachment]]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/mail/emails/sendEmail",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.SendEmailSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.MailBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="sendEmail",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SendEmailResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                errors.BadRequestErrorData, http_res
            )
            raise errors.BadRequestError(response_data, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.NotFoundErrorData, http_res)
            raise errors.NotFoundError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.SendEmailInternalServerErrorData, http_res
            )
            raise errors.SendEmailInternalServerError(response_data, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def send_async(
        self,
        *,
        security: Union[models.SendEmailSecurity, models.SendEmailSecurityTypedDict],
        email_template_type: models.EmailTemplateType,
        send_email_to: List[str],
        product_name: Optional[str] = None,
        is_auto_email: Optional[bool] = False,
        from_email_domain: Optional[str] = None,
        subject: Optional[str] = None,
        template_data: Optional[
            Union[models.TemplateData, models.TemplateDataTypedDict]
        ] = None,
        send_cc_to: Optional[List[str]] = None,
        attachments: Optional[
            Union[List[models.Attachment], List[models.AttachmentTypedDict]]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SendEmailResponse:
        r"""Send a transactional email

        Send a transactional email using the configured SMTP server with a pre-defined template.<br><br>

        <b>Overview:</b><br>
        This is an internal service endpoint used by other PipesHub services to send transactional emails.
        It uses Handlebars templates to generate HTML emails with dynamic content. All sent emails are
        logged to the database for audit purposes.<br><br>

        <b>Authentication:</b><br>
        Requires a scoped token with <code>mail:send</code> scope. This endpoint is not accessible
        with regular user JWT tokens - it is designed for service-to-service communication only.<br><br>

        <b>Available Templates:</b><br>
        <ul>
        <li><b>loginWithOTP</b> - Send OTP code for user authentication. Requires: <code>name</code>, <code>otp</code></li>
        <li><b>resetPassword</b> - Password reset link. Requires: <code>name</code>, <code>link</code></li>
        <li><b>accountCreation</b> - Welcome email for new organizations. Requires: <code>orgName</code>, <code>link</code></li>
        <li><b>appuserInvite</b> - Invitation to join organization. Requires: <code>invitee</code>, <code>orgName</code>, <code>link</code></li>
        <li><b>suspiciousLoginAttempt</b> - Security alert. Requires: <code>link</code></li>
        </ul>

        <b>Email Delivery Flow:</b><br>
        <ol>
        <li>Validate SMTP configuration exists (middleware check)</li>
        <li>Validate scoped token has <code>mail:send</code> scope</li>
        <li>Select and compile Handlebars template with provided data</li>
        <li>Send email via nodemailer using SMTP configuration</li>
        <li>Log email metadata to MongoDB (subject, from, to, cc, templateType)</li>
        </ol>

        <b>Important Notes:</b><br>
        <ul>
        <li>The \"From\" address is always taken from SMTP config, not the request body</li>
        <li>Failed email sends return 500 with error details</li>
        <li>Template mismatches throw \"Unknown Template\" error</li>
        <li>SMTP must be configured before using this endpoint</li>
        </ul>

        <b>Related Endpoints:</b><br>
        <ul>
        <li><code>POST /configurationManager/smtpConfig</code> - Configure SMTP server</li>
        <li><code>POST /mail/updateSmtpConfig</code> - Reload SMTP configuration at runtime</li>
        </ul>


        :param security:
        :param email_template_type: Type of email template to use. Each template has specific `templateData` requirements:
            - `loginWithOTP`: OTP authentication email
            - `resetPassword`: Password reset link email
            - `accountCreation`: Welcome email for new organizations
            - `appuserInvite`: Invitation email to join an organization
            - `suspiciousLoginAttempt`: Security alert for multiple failed OTP attempts

        :param send_email_to: List of recipient email addresses (at least one required)
        :param product_name: Name of the product sending the email (used in templates for branding)
        :param is_auto_email: Flag indicating if this is an automated system email (for tracking/filtering purposes)
        :param from_email_domain: Sender email address for audit logging. **Note:** The actual \"From\" address used
            in the email is taken from the SMTP server configuration (`smtpConfig.fromEmail`),
            not this field. This field is stored in the database for record-keeping.

        :param subject: Email subject line
        :param template_data: Dynamic data to populate the email template. Required fields depend on <code>emailTemplateType</code>.<br><br>
            <b>Template Data Requirements:</b><br>
            <ul>
            <li><b>loginWithOTP:</b> See <code>LoginWithOTPTemplateData</code> - requires <code>name</code>, <code>otp</code></li>
            <li><b>resetPassword:</b> See <code>ResetPasswordTemplateData</code> - requires <code>name</code>, <code>link</code></li>
            <li><b>accountCreation:</b> See <code>AccountCreationTemplateData</code> - requires <code>orgName</code>, <code>link</code></li>
            <li><b>appuserInvite:</b> See <code>AppUserInviteTemplateData</code> - requires <code>invitee</code>, <code>orgName</code>, <code>link</code></li>
            <li><b>suspiciousLoginAttempt:</b> See <code>SuspiciousLoginTemplateData</code> - requires <code>link</code></li>
            </ul>

        :param send_cc_to: Optional list of CC recipient email addresses
        :param attachments: Optional email attachments (uses nodemailer attachment format)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.MailBody(
            product_name=product_name,
            email_template_type=email_template_type,
            is_auto_email=is_auto_email,
            from_email_domain=from_email_domain,
            send_email_to=send_email_to,
            subject=subject,
            template_data=utils.get_pydantic_model(
                template_data, Optional[models.TemplateData]
            ),
            send_cc_to=send_cc_to,
            attachments=utils.get_pydantic_model(
                attachments, Optional[List[models.Attachment]]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/mail/emails/sendEmail",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.SendEmailSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.MailBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="sendEmail",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SendEmailResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                errors.BadRequestErrorData, http_res
            )
            raise errors.BadRequestError(response_data, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.NotFoundErrorData, http_res)
            raise errors.NotFoundError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.SendEmailInternalServerErrorData, http_res
            )
            raise errors.SendEmailInternalServerError(response_data, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)
