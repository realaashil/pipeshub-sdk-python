"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from enum import Enum
import httpx
from pipeshub import errors, models, utils
from pipeshub._hooks import HookContext
from pipeshub.types import OptionalNullable, UNSET
from pipeshub.utils import get_security_from_env
from pipeshub.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union


class GetDisplayPictureAcceptEnum(str, Enum):
    IMAGE_JPEG = "image/jpeg"
    IMAGE_PNG = "image/png"


class Users(BaseSDK):
    r"""User management operations"""

    def get_all(
        self,
        *,
        page: Optional[int] = 1,
        limit: Optional[int] = 50,
        search: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAllUsersResponse:
        r"""Get all users

        Retrieve a paginated list of all users in the organization.<br><br>
        <b>Overview:</b><br>
        This endpoint returns all active users in your organization. It's the primary endpoint for listing and displaying users in admin dashboards, user directories, and selection interfaces.<br><br>
        <b>Response Data:</b><br>
        <ul>
        <li>User profile information (name, email, designation)</li>
        <li>Account status (active, pending invitation, disabled)</li>
        <li>Login history (hasLoggedIn flag)</li>
        <li>Timestamps (createdAt, updatedAt)</li>
        </ul>
        <b>Privacy Controls:</b><br>
        <ul>
        <li>Email addresses may be masked based on organization settings</li>
        <li>Sensitive fields (password, tokens) are never exposed</li>
        <li>Deleted users are excluded from results</li>
        </ul>
        <b>Performance Notes:</b><br>
        <ul>
        <li>Results are cached for improved performance</li>
        <li>For large organizations, consider using pagination</li>
        <li>Use <code>/users/by-ids</code> for fetching specific users</li>
        </ul>


        :param page: Page number for pagination (1-based)
        :param limit: Number of users per page
        :param search: Search users by name or email
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAllUsersRequest(
            page=page,
            limit=limit,
            search=search,
        )

        req = self._build_request(
            method="GET",
            path="/users",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllUsers",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetAllUsersResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_all_async(
        self,
        *,
        page: Optional[int] = 1,
        limit: Optional[int] = 50,
        search: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAllUsersResponse:
        r"""Get all users

        Retrieve a paginated list of all users in the organization.<br><br>
        <b>Overview:</b><br>
        This endpoint returns all active users in your organization. It's the primary endpoint for listing and displaying users in admin dashboards, user directories, and selection interfaces.<br><br>
        <b>Response Data:</b><br>
        <ul>
        <li>User profile information (name, email, designation)</li>
        <li>Account status (active, pending invitation, disabled)</li>
        <li>Login history (hasLoggedIn flag)</li>
        <li>Timestamps (createdAt, updatedAt)</li>
        </ul>
        <b>Privacy Controls:</b><br>
        <ul>
        <li>Email addresses may be masked based on organization settings</li>
        <li>Sensitive fields (password, tokens) are never exposed</li>
        <li>Deleted users are excluded from results</li>
        </ul>
        <b>Performance Notes:</b><br>
        <ul>
        <li>Results are cached for improved performance</li>
        <li>For large organizations, consider using pagination</li>
        <li>Use <code>/users/by-ids</code> for fetching specific users</li>
        </ul>


        :param page: Page number for pagination (1-based)
        :param limit: Number of users per page
        :param search: Search users by name or email
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAllUsersRequest(
            page=page,
            limit=limit,
            search=search,
        )

        req = self._build_request_async(
            method="GET",
            path="/users",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllUsers",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetAllUsersResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def create(
        self,
        *,
        full_name: str,
        email: str,
        mobile: Optional[str] = None,
        designation: Optional[str] = None,
        send_invite: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateUserResponse:
        r"""Create a new user

        Create a new user account in the organization and optionally send an invitation email.<br><br>
        <b>Overview:</b><br>
        This endpoint creates a new user account. The user will be added to the organization but won't have a password set until they complete the invitation flow or are assigned one by an admin.<br><br>
        <b>Invitation Flow:</b><br>
        <ol>
        <li>Admin creates user with this endpoint</li>
        <li>System generates invitation token</li>
        <li>User receives invitation email (if sendInvite is true)</li>
        <li>User clicks link and sets their password</li>
        <li>User can now log in normally</li>
        </ol>
        <b>Validation Rules:</b><br>
        <ul>
        <li><code>fullName</code>: Required, 1-100 characters</li>
        <li><code>email</code>: Required, valid email format, must be unique in org</li>
        <li><code>mobile</code>: Optional, format: +[country][number] (10-15 digits)</li>
        <li><code>designation</code>: Optional, job title or role</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>User is automatically added to the \"everyone\" group</li>
        <li>Invitation email sent if <code>sendInvite: true</code></li>
        <li>User creation event published to event bus</li>
        <li>Audit log entry created</li>
        </ul>
        <b>Authorization:</b><br>
        Only organization administrators can create new users.


        :param full_name: User's full display name
        :param email: User's email address (must be unique)
        :param mobile: Mobile phone number with country code
        :param designation: Job title or designation
        :param send_invite: Whether to send invitation email immediately
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateUserRequest(
            full_name=full_name,
            email=email,
            mobile=mobile,
            designation=designation,
            send_invite=send_invite,
        )

        req = self._build_request(
            method="POST",
            path="/users",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateUserRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.CreateUserResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        full_name: str,
        email: str,
        mobile: Optional[str] = None,
        designation: Optional[str] = None,
        send_invite: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateUserResponse:
        r"""Create a new user

        Create a new user account in the organization and optionally send an invitation email.<br><br>
        <b>Overview:</b><br>
        This endpoint creates a new user account. The user will be added to the organization but won't have a password set until they complete the invitation flow or are assigned one by an admin.<br><br>
        <b>Invitation Flow:</b><br>
        <ol>
        <li>Admin creates user with this endpoint</li>
        <li>System generates invitation token</li>
        <li>User receives invitation email (if sendInvite is true)</li>
        <li>User clicks link and sets their password</li>
        <li>User can now log in normally</li>
        </ol>
        <b>Validation Rules:</b><br>
        <ul>
        <li><code>fullName</code>: Required, 1-100 characters</li>
        <li><code>email</code>: Required, valid email format, must be unique in org</li>
        <li><code>mobile</code>: Optional, format: +[country][number] (10-15 digits)</li>
        <li><code>designation</code>: Optional, job title or role</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>User is automatically added to the \"everyone\" group</li>
        <li>Invitation email sent if <code>sendInvite: true</code></li>
        <li>User creation event published to event bus</li>
        <li>Audit log entry created</li>
        </ul>
        <b>Authorization:</b><br>
        Only organization administrators can create new users.


        :param full_name: User's full display name
        :param email: User's email address (must be unique)
        :param mobile: Mobile phone number with country code
        :param designation: Job title or designation
        :param send_invite: Whether to send invitation email immediately
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateUserRequest(
            full_name=full_name,
            email=email,
            mobile=mobile,
            designation=designation,
            send_invite=send_invite,
        )

        req = self._build_request_async(
            method="POST",
            path="/users",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateUserRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.CreateUserResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_by_id(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUserByIDResponse:
        r"""Get user by ID

        Retrieve detailed information about a specific user by their unique identifier.<br><br>
        <b>Overview:</b><br>
        This endpoint returns the complete user profile for the specified user ID. Use this to display user details in profiles, settings pages, or when you need full user information.<br><br>
        <b>Response Data:</b><br>
        <ul>
        <li>Basic info: fullName, firstName, lastName, email</li>
        <li>Contact: mobile, address</li>
        <li>Professional: designation</li>
        <li>Status: hasLoggedIn, isDeleted, accountStatus</li>
        <li>Metadata: createdAt, updatedAt, createdBy</li>
        </ul>
        <b>Privacy Notes:</b><br>
        <ul>
        <li>Email may be masked for non-admin users based on org settings</li>
        <li>Password and sensitive tokens are never returned</li>
        <li>Display picture URL returned if set</li>
        </ul>
        <b>Related Endpoints:</b><br>
        <ul>
        <li><code>GET /users/{id}/email</code> - Get just the email (admin only)</li>
        <li><code>GET /users/fetch/with-groups</code> - Get user with group memberships</li>
        </ul>


        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetUserByIDRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/users/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUserById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetUserByIDResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_by_id_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUserByIDResponse:
        r"""Get user by ID

        Retrieve detailed information about a specific user by their unique identifier.<br><br>
        <b>Overview:</b><br>
        This endpoint returns the complete user profile for the specified user ID. Use this to display user details in profiles, settings pages, or when you need full user information.<br><br>
        <b>Response Data:</b><br>
        <ul>
        <li>Basic info: fullName, firstName, lastName, email</li>
        <li>Contact: mobile, address</li>
        <li>Professional: designation</li>
        <li>Status: hasLoggedIn, isDeleted, accountStatus</li>
        <li>Metadata: createdAt, updatedAt, createdBy</li>
        </ul>
        <b>Privacy Notes:</b><br>
        <ul>
        <li>Email may be masked for non-admin users based on org settings</li>
        <li>Password and sensitive tokens are never returned</li>
        <li>Display picture URL returned if set</li>
        </ul>
        <b>Related Endpoints:</b><br>
        <ul>
        <li><code>GET /users/{id}/email</code> - Get just the email (admin only)</li>
        <li><code>GET /users/fetch/with-groups</code> - Get user with group memberships</li>
        </ul>


        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetUserByIDRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUserById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetUserByIDResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update(
        self,
        *,
        id: str,
        full_name: Optional[str] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        email: Optional[str] = None,
        mobile: Optional[str] = None,
        designation: Optional[str] = None,
        address: Optional[Union[models.Address, models.AddressTypedDict]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserResponse:
        r"""Update user

        Update user profile information. Users can update their own profile, admins can update any user.<br><br>
        <b>Overview:</b><br>
        This endpoint allows updating user profile fields. The scope of allowed updates depends on the requester's role and relationship to the user being updated.<br><br>
        <b>Authorization Matrix:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own fullName, mobile, designation, address</li>
        <li><b>Admin-update:</b> Admins can update any field for any user</li>
        <li><b>Email changes:</b> Require admin privileges and trigger re-verification</li>
        </ul>
        <b>Updatable Fields:</b><br>
        <ul>
        <li><code>fullName</code>: Display name (also updates firstName/lastName if parsed)</li>
        <li><code>firstName</code>: First name only</li>
        <li><code>lastName</code>: Last name only</li>
        <li><code>email</code>: Email address (admin only, triggers verification)</li>
        <li><code>mobile</code>: Phone number with country code</li>
        <li><code>designation</code>: Job title</li>
        <li><code>address</code>: Full address object</li>
        </ul>
        <b>Validation Rules:</b><br>
        <ul>
        <li>Email must be unique within the organization</li>
        <li>Mobile must match pattern: +[country][number]</li>
        <li>Name fields: 1-100 characters</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>User update event published to event bus</li>
        <li>Audit log entry created for admin updates</li>
        <li>Email change triggers verification email</li>
        </ul>


        :param id: User ID (24-character MongoDB ObjectId)
        :param full_name: Full display name
        :param first_name: First name only
        :param last_name: Last name only
        :param email: Email address (admin only)
        :param mobile: Mobile phone with country code
        :param designation: Job title or role
        :param address:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserRequest(
            id=id,
            body=models.UpdateUserRequestBody(
                full_name=full_name,
                first_name=first_name,
                last_name=last_name,
                email=email,
                mobile=mobile,
                designation=designation,
                address=utils.get_pydantic_model(address, Optional[models.Address]),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/users/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.UpdateUserRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateUserResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        id: str,
        full_name: Optional[str] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        email: Optional[str] = None,
        mobile: Optional[str] = None,
        designation: Optional[str] = None,
        address: Optional[Union[models.Address, models.AddressTypedDict]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserResponse:
        r"""Update user

        Update user profile information. Users can update their own profile, admins can update any user.<br><br>
        <b>Overview:</b><br>
        This endpoint allows updating user profile fields. The scope of allowed updates depends on the requester's role and relationship to the user being updated.<br><br>
        <b>Authorization Matrix:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own fullName, mobile, designation, address</li>
        <li><b>Admin-update:</b> Admins can update any field for any user</li>
        <li><b>Email changes:</b> Require admin privileges and trigger re-verification</li>
        </ul>
        <b>Updatable Fields:</b><br>
        <ul>
        <li><code>fullName</code>: Display name (also updates firstName/lastName if parsed)</li>
        <li><code>firstName</code>: First name only</li>
        <li><code>lastName</code>: Last name only</li>
        <li><code>email</code>: Email address (admin only, triggers verification)</li>
        <li><code>mobile</code>: Phone number with country code</li>
        <li><code>designation</code>: Job title</li>
        <li><code>address</code>: Full address object</li>
        </ul>
        <b>Validation Rules:</b><br>
        <ul>
        <li>Email must be unique within the organization</li>
        <li>Mobile must match pattern: +[country][number]</li>
        <li>Name fields: 1-100 characters</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>User update event published to event bus</li>
        <li>Audit log entry created for admin updates</li>
        <li>Email change triggers verification email</li>
        </ul>


        :param id: User ID (24-character MongoDB ObjectId)
        :param full_name: Full display name
        :param first_name: First name only
        :param last_name: Last name only
        :param email: Email address (admin only)
        :param mobile: Mobile phone with country code
        :param designation: Job title or role
        :param address:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserRequest(
            id=id,
            body=models.UpdateUserRequestBody(
                full_name=full_name,
                first_name=first_name,
                last_name=last_name,
                email=email,
                mobile=mobile,
                designation=designation,
                address=utils.get_pydantic_model(address, Optional[models.Address]),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/users/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.UpdateUserRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateUserResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteUserResponse:
        r"""Delete user

        Soft delete a user from the organization. The user account is deactivated but data is retained for audit purposes.<br><br>
        <b>Overview:</b><br>
        This endpoint performs a soft delete on a user account. The user is marked as deleted and can no longer access the system, but their data is retained for compliance and audit purposes.<br><br>
        <b>What Happens on Delete:</b><br>
        <ol>
        <li>User's <code>isDeleted</code> flag is set to true</li>
        <li>User's password is cleared</li>
        <li>User is removed from all user groups</li>
        <li>User's active sessions are invalidated</li>
        <li>User deletion event is published</li>
        </ol>
        <b>Restrictions:</b><br>
        <ul>
        <li>Cannot delete organization admins (demote first)</li>
        <li>Cannot delete the organization owner</li>
        <li>Cannot delete yourself through this endpoint</li>
        <li>Cannot delete already-deleted users</li>
        </ul>
        <b>Data Retention:</b><br>
        <ul>
        <li>User profile data is retained (soft delete)</li>
        <li>User's documents and content remain with updated ownership</li>
        <li>Audit logs are preserved</li>
        <li>Data can be permanently purged by super admin if required</li>
        </ul>
        <b>Recovery:</b><br>
        Deleted users can be restored by organization admins within a configurable retention period.


        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteUserRequest(
            id=id,
        )

        req = self._build_request(
            method="DELETE",
            path="/users/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DeleteUserResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteUserResponse:
        r"""Delete user

        Soft delete a user from the organization. The user account is deactivated but data is retained for audit purposes.<br><br>
        <b>Overview:</b><br>
        This endpoint performs a soft delete on a user account. The user is marked as deleted and can no longer access the system, but their data is retained for compliance and audit purposes.<br><br>
        <b>What Happens on Delete:</b><br>
        <ol>
        <li>User's <code>isDeleted</code> flag is set to true</li>
        <li>User's password is cleared</li>
        <li>User is removed from all user groups</li>
        <li>User's active sessions are invalidated</li>
        <li>User deletion event is published</li>
        </ol>
        <b>Restrictions:</b><br>
        <ul>
        <li>Cannot delete organization admins (demote first)</li>
        <li>Cannot delete the organization owner</li>
        <li>Cannot delete yourself through this endpoint</li>
        <li>Cannot delete already-deleted users</li>
        </ul>
        <b>Data Retention:</b><br>
        <ul>
        <li>User profile data is retained (soft delete)</li>
        <li>User's documents and content remain with updated ownership</li>
        <li>Audit logs are preserved</li>
        <li>Data can be permanently purged by super admin if required</li>
        </ul>
        <b>Recovery:</b><br>
        Deleted users can be restored by organization admins within a configurable retention period.


        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteUserRequest(
            id=id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/users/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DeleteUserResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_all_with_groups(
        self,
        *,
        include_deleted: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAllUsersWithGroupsResponse:
        r"""Get all users with their groups

        Retrieve all users along with their group memberships in a single optimized query.<br><br>
        <b>Overview:</b><br>
        This endpoint returns users with their associated groups pre-loaded, eliminating the need for separate group lookup calls. Ideal for admin dashboards that need to display user permissions at a glance.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Admin dashboards showing user-group matrix</li>
        <li>Permission auditing and compliance checks</li>
        <li>Bulk user management interfaces</li>
        <li>Access control visualization</li>
        </ul>
        <b>Response Data per User:</b><br>
        <ul>
        <li><code>_id</code>: User's unique identifier</li>
        <li><code>userId</code>: User's public-facing ID</li>
        <li><code>orgId</code>: Organization identifier</li>
        <li><code>fullName</code>: User's display name</li>
        <li><code>hasLoggedIn</code>: Whether user has ever logged in</li>
        <li><code>groups</code>: Array of group objects with name and type</li>
        </ul>
        <b>Group Types Returned:</b><br>
        <ul>
        <li><code>admin</code>: Administrative groups with elevated permissions</li>
        <li><code>standard</code>: Regular user groups</li>
        <li><code>everyone</code>: Default group containing all org users</li>
        <li><code>custom</code>: Custom groups created by admins</li>
        </ul>
        <b>Performance Notes:</b><br>
        Uses aggregation pipeline for efficient single-query retrieval. Cached results for improved performance on large organizations.


        :param include_deleted: Include soft-deleted users (admin only)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAllUsersWithGroupsRequest(
            include_deleted=include_deleted,
        )

        req = self._build_request(
            method="GET",
            path="/users/fetch/with-groups",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllUsersWithGroups",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.GetAllUsersWithGroupsResponse, http_res
            )
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_all_with_groups_async(
        self,
        *,
        include_deleted: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAllUsersWithGroupsResponse:
        r"""Get all users with their groups

        Retrieve all users along with their group memberships in a single optimized query.<br><br>
        <b>Overview:</b><br>
        This endpoint returns users with their associated groups pre-loaded, eliminating the need for separate group lookup calls. Ideal for admin dashboards that need to display user permissions at a glance.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Admin dashboards showing user-group matrix</li>
        <li>Permission auditing and compliance checks</li>
        <li>Bulk user management interfaces</li>
        <li>Access control visualization</li>
        </ul>
        <b>Response Data per User:</b><br>
        <ul>
        <li><code>_id</code>: User's unique identifier</li>
        <li><code>userId</code>: User's public-facing ID</li>
        <li><code>orgId</code>: Organization identifier</li>
        <li><code>fullName</code>: User's display name</li>
        <li><code>hasLoggedIn</code>: Whether user has ever logged in</li>
        <li><code>groups</code>: Array of group objects with name and type</li>
        </ul>
        <b>Group Types Returned:</b><br>
        <ul>
        <li><code>admin</code>: Administrative groups with elevated permissions</li>
        <li><code>standard</code>: Regular user groups</li>
        <li><code>everyone</code>: Default group containing all org users</li>
        <li><code>custom</code>: Custom groups created by admins</li>
        </ul>
        <b>Performance Notes:</b><br>
        Uses aggregation pipeline for efficient single-query retrieval. Cached results for improved performance on large organizations.


        :param include_deleted: Include soft-deleted users (admin only)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAllUsersWithGroupsRequest(
            include_deleted=include_deleted,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/fetch/with-groups",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllUsersWithGroups",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.GetAllUsersWithGroupsResponse, http_res
            )
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_email(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUserEmailByIDResponse:
        r"""Get user email by ID

        Retrieve the email address for a specific user. This is a dedicated endpoint for email lookup with proper access controls.<br><br>
        <b>Overview:</b><br>
        This endpoint provides direct access to a user's email address. It exists separately from the main user endpoint to allow granular permission control over email visibility.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Admin communication workflows</li>
        <li>Invitation and notification systems</li>
        <li>Email-based user lookup</li>
        <li>Contact information export</li>
        </ul>
        <b>Privacy Considerations:</b><br>
        <ul>
        <li>Only organization admins can access this endpoint</li>
        <li>Access is logged for audit purposes</li>
        <li>Consider GDPR/privacy regulations when exposing emails</li>
        </ul>
        <b>Authorization:</b><br>
        Requires admin privileges. Regular users should use the main user endpoint which may mask emails based on organization settings.


        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetUserEmailByIDRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/users/{id}/email",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUserEmailById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetUserEmailByIDResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_email_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUserEmailByIDResponse:
        r"""Get user email by ID

        Retrieve the email address for a specific user. This is a dedicated endpoint for email lookup with proper access controls.<br><br>
        <b>Overview:</b><br>
        This endpoint provides direct access to a user's email address. It exists separately from the main user endpoint to allow granular permission control over email visibility.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Admin communication workflows</li>
        <li>Invitation and notification systems</li>
        <li>Email-based user lookup</li>
        <li>Contact information export</li>
        </ul>
        <b>Privacy Considerations:</b><br>
        <ul>
        <li>Only organization admins can access this endpoint</li>
        <li>Access is logged for audit purposes</li>
        <li>Consider GDPR/privacy regulations when exposing emails</li>
        </ul>
        <b>Authorization:</b><br>
        Requires admin privileges. Regular users should use the main user endpoint which may mask emails based on organization settings.


        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetUserEmailByIDRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/{id}/email",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUserEmailById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetUserEmailByIDResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_by_ids(
        self,
        *,
        user_ids: List[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUsersByIdsResponse:
        r"""Get users by IDs (bulk)

        Retrieve multiple users by their IDs in a single optimized request. Ideal for efficiently fetching a specific set of users.<br><br>
        <b>Overview:</b><br>
        This bulk endpoint allows fetching multiple users in a single API call, reducing network overhead when you need to display information about several known users.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Fetching user details for a list of team members</li>
        <li>Populating user cards in a dashboard</li>
        <li>Loading participants in a document or conversation</li>
        <li>Building user mention/autocomplete features</li>
        </ul>
        <b>Request Format:</b><br>
        <ul>
        <li>Send array of user IDs in request body</li>
        <li>Each ID must be valid 24-character MongoDB ObjectId</li>
        <li>Maximum 100 IDs per request (for performance)</li>
        <li>Duplicate IDs are automatically deduplicated</li>
        </ul>
        <b>Response Behavior:</b><br>
        <ul>
        <li>Returns array of found users</li>
        <li>Order matches order of requested IDs</li>
        <li>Non-existent or deleted users are silently omitted</li>
        <li>Partial results returned if some IDs are invalid</li>
        </ul>
        <b>Performance Notes:</b><br>
        Uses single database query with $in operator for optimal performance. Preferable to multiple individual user fetches.


        :param user_ids: Array of user IDs to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetUsersByIdsRequest(
            user_ids=user_ids,
        )

        req = self._build_request(
            method="POST",
            path="/users/by-ids",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetUsersByIdsRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUsersByIds",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetUsersByIdsResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_by_ids_async(
        self,
        *,
        user_ids: List[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUsersByIdsResponse:
        r"""Get users by IDs (bulk)

        Retrieve multiple users by their IDs in a single optimized request. Ideal for efficiently fetching a specific set of users.<br><br>
        <b>Overview:</b><br>
        This bulk endpoint allows fetching multiple users in a single API call, reducing network overhead when you need to display information about several known users.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Fetching user details for a list of team members</li>
        <li>Populating user cards in a dashboard</li>
        <li>Loading participants in a document or conversation</li>
        <li>Building user mention/autocomplete features</li>
        </ul>
        <b>Request Format:</b><br>
        <ul>
        <li>Send array of user IDs in request body</li>
        <li>Each ID must be valid 24-character MongoDB ObjectId</li>
        <li>Maximum 100 IDs per request (for performance)</li>
        <li>Duplicate IDs are automatically deduplicated</li>
        </ul>
        <b>Response Behavior:</b><br>
        <ul>
        <li>Returns array of found users</li>
        <li>Order matches order of requested IDs</li>
        <li>Non-existent or deleted users are silently omitted</li>
        <li>Partial results returned if some IDs are invalid</li>
        </ul>
        <b>Performance Notes:</b><br>
        Uses single database query with $in operator for optimal performance. Preferable to multiple individual user fetches.


        :param user_ids: Array of user IDs to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetUsersByIdsRequest(
            user_ids=user_ids,
        )

        req = self._build_request_async(
            method="POST",
            path="/users/by-ids",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetUsersByIdsRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUsersByIds",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetUsersByIdsResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def exists_by_email(
        self,
        *,
        security: Union[
            models.CheckUserExistsByEmailSecurity,
            models.CheckUserExistsByEmailSecurityTypedDict,
        ],
        email: str,
        include_deleted: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CheckUserExistsByEmailResponse:
        r"""Check if user exists by email

        Check if a user account exists with the given email address. Used for pre-validation in registration and invitation flows.<br><br>
        <b>Overview:</b><br>
        This internal service endpoint validates email existence before creating accounts or sending invitations. It helps prevent duplicate accounts and validates recovery email addresses.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Pre-flight check before user invitation</li>
        <li>Email validation during registration</li>
        <li>Account recovery flow validation</li>
        <li>Duplicate prevention checks</li>
        </ul>
        <b>Security Model:</b><br>
        <ul>
        <li>Requires scoped token with USER_LOOKUP privilege</li>
        <li>Not accessible with regular bearer tokens</li>
        <li>Typically called from internal services only</li>
        </ul>
        <b>Response Behavior:</b><br>
        <ul>
        <li>Returns matching users (including soft-deleted for recovery)</li>
        <li>Empty array if no match found</li>
        <li>Does not expose whether email exists to prevent enumeration</li>
        </ul>
        <b>Note:</b> May return soft-deleted users to support account recovery workflows.


        :param security:
        :param email: Email address to check
        :param include_deleted: Whether to include soft-deleted users
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CheckUserExistsByEmailRequest(
            email=email,
            include_deleted=include_deleted,
        )

        req = self._build_request(
            method="GET",
            path="/users/email/exists",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CheckUserExistsByEmailSecurity
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="checkUserExistsByEmail",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.CheckUserExistsByEmailResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def exists_by_email_async(
        self,
        *,
        security: Union[
            models.CheckUserExistsByEmailSecurity,
            models.CheckUserExistsByEmailSecurityTypedDict,
        ],
        email: str,
        include_deleted: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CheckUserExistsByEmailResponse:
        r"""Check if user exists by email

        Check if a user account exists with the given email address. Used for pre-validation in registration and invitation flows.<br><br>
        <b>Overview:</b><br>
        This internal service endpoint validates email existence before creating accounts or sending invitations. It helps prevent duplicate accounts and validates recovery email addresses.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>Pre-flight check before user invitation</li>
        <li>Email validation during registration</li>
        <li>Account recovery flow validation</li>
        <li>Duplicate prevention checks</li>
        </ul>
        <b>Security Model:</b><br>
        <ul>
        <li>Requires scoped token with USER_LOOKUP privilege</li>
        <li>Not accessible with regular bearer tokens</li>
        <li>Typically called from internal services only</li>
        </ul>
        <b>Response Behavior:</b><br>
        <ul>
        <li>Returns matching users (including soft-deleted for recovery)</li>
        <li>Empty array if no match found</li>
        <li>Does not expose whether email exists to prevent enumeration</li>
        </ul>
        <b>Note:</b> May return soft-deleted users to support account recovery workflows.


        :param security:
        :param email: Email address to check
        :param include_deleted: Whether to include soft-deleted users
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CheckUserExistsByEmailRequest(
            email=email,
            include_deleted=include_deleted,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/email/exists",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CheckUserExistsByEmailSecurity
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="checkUserExistsByEmail",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.CheckUserExistsByEmailResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_internal(
        self,
        *,
        security: Union[
            models.GetInternalUserSecurity, models.GetInternalUserSecurityTypedDict
        ],
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetInternalUserResponse:
        r"""Get user (internal service-to-service)

        Internal endpoint for service-to-service user lookup. Returns complete user data without privacy masking.<br><br>
        <b>Overview:</b><br>
        This internal endpoint provides full user data access for trusted backend services. Unlike public endpoints, it bypasses privacy controls and returns complete user information.<br><br>
        <b>Security Model:</b><br>
        <ul>
        <li>Requires scoped token with USER_LOOKUP privilege</li>
        <li>Not accessible via regular bearer tokens</li>
        <li>Intended for trusted internal services only</li>
        <li>All access is logged for audit purposes</li>
        </ul>
        <b>Intended Consumers:</b><br>
        <ul>
        <li>Email notification service</li>
        <li>Analytics and reporting services</li>
        <li>Audit logging service</li>
        <li>Integration sync services</li>
        </ul>
        <b>Data Returned:</b><br>
        Complete user object including fields that may be masked in public endpoints (email, phone, etc.).<br><br>
        <b>Warning:</b><br>
        This endpoint returns sensitive data. Ensure consuming services handle data according to privacy policies.


        :param security:
        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInternalUserRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/users/internal/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInternalUserSecurity),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getInternalUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetInternalUserResponse, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_internal_async(
        self,
        *,
        security: Union[
            models.GetInternalUserSecurity, models.GetInternalUserSecurityTypedDict
        ],
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetInternalUserResponse:
        r"""Get user (internal service-to-service)

        Internal endpoint for service-to-service user lookup. Returns complete user data without privacy masking.<br><br>
        <b>Overview:</b><br>
        This internal endpoint provides full user data access for trusted backend services. Unlike public endpoints, it bypasses privacy controls and returns complete user information.<br><br>
        <b>Security Model:</b><br>
        <ul>
        <li>Requires scoped token with USER_LOOKUP privilege</li>
        <li>Not accessible via regular bearer tokens</li>
        <li>Intended for trusted internal services only</li>
        <li>All access is logged for audit purposes</li>
        </ul>
        <b>Intended Consumers:</b><br>
        <ul>
        <li>Email notification service</li>
        <li>Analytics and reporting services</li>
        <li>Audit logging service</li>
        <li>Integration sync services</li>
        </ul>
        <b>Data Returned:</b><br>
        Complete user object including fields that may be masked in public endpoints (email, phone, etc.).<br><br>
        <b>Warning:</b><br>
        This endpoint returns sensitive data. Ensure consuming services handle data according to privacy policies.


        :param security:
        :param id: User ID (24-character MongoDB ObjectId)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInternalUserRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/internal/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInternalUserSecurity),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getInternalUser",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetInternalUserResponse, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update_full_name(
        self,
        *,
        id: str,
        full_name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.User:
        r"""Update user full name

        Update the full name of a user. This is a targeted update endpoint for changing only the display name without affecting other profile fields.<br><br>
        <b>Overview:</b><br>
        This endpoint updates a user's fullName field, which is their primary display name throughout the application. The firstName and lastName fields may also be updated based on name parsing logic.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own full name</li>
        <li><b>Admin-update:</b> Admins can update any user's name</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>Updates fullName field</li>
        <li>May parse and update firstName/lastName</li>
        <li>User update event published</li>
        <li>Cached user data invalidated</li>
        </ul>
        <b>Use Cases:</b><br>
        <ul>
        <li>User profile name change</li>
        <li>Name correction by admin</li>
        <li>Legal name update</li>
        </ul>


        :param id:
        :param full_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserFullNameRequest(
            id=id,
            body=models.UpdateUserFullNameRequestBody(
                full_name=full_name,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/users/{id}/fullname",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.UpdateUserFullNameRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserFullName",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.User, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_full_name_async(
        self,
        *,
        id: str,
        full_name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.User:
        r"""Update user full name

        Update the full name of a user. This is a targeted update endpoint for changing only the display name without affecting other profile fields.<br><br>
        <b>Overview:</b><br>
        This endpoint updates a user's fullName field, which is their primary display name throughout the application. The firstName and lastName fields may also be updated based on name parsing logic.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own full name</li>
        <li><b>Admin-update:</b> Admins can update any user's name</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>Updates fullName field</li>
        <li>May parse and update firstName/lastName</li>
        <li>User update event published</li>
        <li>Cached user data invalidated</li>
        </ul>
        <b>Use Cases:</b><br>
        <ul>
        <li>User profile name change</li>
        <li>Name correction by admin</li>
        <li>Legal name update</li>
        </ul>


        :param id:
        :param full_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserFullNameRequest(
            id=id,
            body=models.UpdateUserFullNameRequestBody(
                full_name=full_name,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/users/{id}/fullname",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.UpdateUserFullNameRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserFullName",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.User, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update_first_name(
        self,
        *,
        id: str,
        first_name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserFirstNameResponse:
        r"""Update user first name

        Update only the first name of a user without affecting other profile fields.<br><br>
        <b>Overview:</b><br>
        This targeted endpoint updates just the firstName field. Useful when you need fine-grained control over name components rather than updating the full name.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own first name</li>
        <li><b>Admin-update:</b> Admins can update any user's first name</li>
        </ul>
        <b>Note:</b> This does NOT automatically update the fullName field. Use <code>/users/{id}/fullname</code> if you need to update the complete display name.


        :param id: User ID (24-character MongoDB ObjectId)
        :param first_name: New first name
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserFirstNameRequest(
            id=id,
            body=models.UpdateUserFirstNameRequestBody(
                first_name=first_name,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/users/{id}/firstName",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UpdateUserFirstNameRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserFirstName",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateUserFirstNameResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_first_name_async(
        self,
        *,
        id: str,
        first_name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserFirstNameResponse:
        r"""Update user first name

        Update only the first name of a user without affecting other profile fields.<br><br>
        <b>Overview:</b><br>
        This targeted endpoint updates just the firstName field. Useful when you need fine-grained control over name components rather than updating the full name.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own first name</li>
        <li><b>Admin-update:</b> Admins can update any user's first name</li>
        </ul>
        <b>Note:</b> This does NOT automatically update the fullName field. Use <code>/users/{id}/fullname</code> if you need to update the complete display name.


        :param id: User ID (24-character MongoDB ObjectId)
        :param first_name: New first name
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserFirstNameRequest(
            id=id,
            body=models.UpdateUserFirstNameRequestBody(
                first_name=first_name,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/users/{id}/firstName",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UpdateUserFirstNameRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserFirstName",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateUserFirstNameResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update_last_name(
        self,
        *,
        id: str,
        last_name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserLastNameResponse:
        r"""Update user last name

        Update only the last name of a user without affecting other profile fields.<br><br>
        <b>Overview:</b><br>
        This targeted endpoint updates just the lastName field. Useful for fine-grained control over name components.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own last name</li>
        <li><b>Admin-update:</b> Admins can update any user's last name</li>
        </ul>
        <b>Note:</b> This does NOT automatically update the fullName field. Use <code>/users/{id}/fullname</code> if you need to update the complete display name.


        :param id: User ID (24-character MongoDB ObjectId)
        :param last_name: New last name
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserLastNameRequest(
            id=id,
            body=models.UpdateUserLastNameRequestBody(
                last_name=last_name,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/users/{id}/lastName",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.UpdateUserLastNameRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserLastName",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateUserLastNameResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_last_name_async(
        self,
        *,
        id: str,
        last_name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserLastNameResponse:
        r"""Update user last name

        Update only the last name of a user without affecting other profile fields.<br><br>
        <b>Overview:</b><br>
        This targeted endpoint updates just the lastName field. Useful for fine-grained control over name components.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own last name</li>
        <li><b>Admin-update:</b> Admins can update any user's last name</li>
        </ul>
        <b>Note:</b> This does NOT automatically update the fullName field. Use <code>/users/{id}/fullname</code> if you need to update the complete display name.


        :param id: User ID (24-character MongoDB ObjectId)
        :param last_name: New last name
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserLastNameRequest(
            id=id,
            body=models.UpdateUserLastNameRequestBody(
                last_name=last_name,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/users/{id}/lastName",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.UpdateUserLastNameRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserLastName",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateUserLastNameResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update_designation(
        self,
        *,
        id: str,
        designation: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserDesignationResponse:
        r"""Update user designation

        Update the job title or designation of a user.<br><br>
        <b>Overview:</b><br>
        This endpoint updates the user's designation field, which typically represents their job title, role, or position within the organization.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own designation</li>
        <li><b>Admin-update:</b> Admins can update any user's designation</li>
        </ul>
        <b>Common Values:</b><br>
        <ul>
        <li>Software Engineer</li>
        <li>Product Manager</li>
        <li>Team Lead</li>
        <li>Director of Engineering</li>
        </ul>
        <b>Display:</b><br>
        Designation is shown in user profiles, team views, and organizational charts.


        :param id: User ID (24-character MongoDB ObjectId)
        :param designation: Job title or designation
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserDesignationRequest(
            id=id,
            body=models.UpdateUserDesignationRequestBody(
                designation=designation,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/users/{id}/designation",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UpdateUserDesignationRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserDesignation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.UpdateUserDesignationResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_designation_async(
        self,
        *,
        id: str,
        designation: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateUserDesignationResponse:
        r"""Update user designation

        Update the job title or designation of a user.<br><br>
        <b>Overview:</b><br>
        This endpoint updates the user's designation field, which typically represents their job title, role, or position within the organization.<br><br>
        <b>Authorization:</b><br>
        <ul>
        <li><b>Self-update:</b> Users can update their own designation</li>
        <li><b>Admin-update:</b> Admins can update any user's designation</li>
        </ul>
        <b>Common Values:</b><br>
        <ul>
        <li>Software Engineer</li>
        <li>Product Manager</li>
        <li>Team Lead</li>
        <li>Director of Engineering</li>
        </ul>
        <b>Display:</b><br>
        Designation is shown in user profiles, team views, and organizational charts.


        :param id: User ID (24-character MongoDB ObjectId)
        :param designation: Job title or designation
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateUserDesignationRequest(
            id=id,
            body=models.UpdateUserDesignationRequestBody(
                designation=designation,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/users/{id}/designation",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                False,
                "json",
                models.UpdateUserDesignationRequestBody,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateUserDesignation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.UpdateUserDesignationResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def check_admin_status(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CheckUserIsAdminResponse:
        r"""Check if user is admin

        Verify whether a specific user has administrative privileges in the organization.<br><br>
        <b>Overview:</b><br>
        This endpoint checks if the specified user belongs to an admin group and has elevated permissions. It's useful for authorization checks before performing admin-only operations.<br><br>
        <b>What Makes a User an Admin:</b><br>
        <ul>
        <li>Member of a group with type \"admin\"</li>
        <li>Has explicit admin role assignment</li>
        <li>Organization owner (always admin)</li>
        </ul>
        <b>Use Cases:</b><br>
        <ul>
        <li>UI permission checks before showing admin features</li>
        <li>Pre-flight authorization validation</li>
        <li>Access control for sensitive operations</li>
        </ul>
        <b>Response Codes:</b><br>
        <ul>
        <li><code>200</code>: User IS an admin</li>
        <li><code>403</code>: User is NOT an admin</li>
        </ul>


        :param id: User ID to check for admin privileges
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CheckUserIsAdminRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/users/{id}/adminCheck",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="checkUserIsAdmin",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CheckUserIsAdminResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def check_admin_status_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CheckUserIsAdminResponse:
        r"""Check if user is admin

        Verify whether a specific user has administrative privileges in the organization.<br><br>
        <b>Overview:</b><br>
        This endpoint checks if the specified user belongs to an admin group and has elevated permissions. It's useful for authorization checks before performing admin-only operations.<br><br>
        <b>What Makes a User an Admin:</b><br>
        <ul>
        <li>Member of a group with type \"admin\"</li>
        <li>Has explicit admin role assignment</li>
        <li>Organization owner (always admin)</li>
        </ul>
        <b>Use Cases:</b><br>
        <ul>
        <li>UI permission checks before showing admin features</li>
        <li>Pre-flight authorization validation</li>
        <li>Access control for sensitive operations</li>
        </ul>
        <b>Response Codes:</b><br>
        <ul>
        <li><code>200</code>: User IS an admin</li>
        <li><code>403</code>: User is NOT an admin</li>
        </ul>


        :param id: User ID to check for admin privileges
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CheckUserIsAdminRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/{id}/adminCheck",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="checkUserIsAdmin",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CheckUserIsAdminResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def upload_display_picture(
        self,
        *,
        file: Union[
            models.UploadUserDisplayPictureFile,
            models.UploadUserDisplayPictureFileTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Upload display picture

        Upload or update the display picture (avatar) for the authenticated user.<br><br>
        <b>Overview:</b><br>
        This endpoint allows users to upload their profile picture. The image is processed, resized, and stored for use throughout the application.<br><br>
        <b>File Requirements:</b><br>
        <ul>
        <li><b>Allowed types:</b> PNG, JPEG, JPG, WebP, GIF</li>
        <li><b>Maximum size:</b> 1MB (1,048,576 bytes)</li>
        <li><b>Recommended dimensions:</b> 256x256 pixels or larger</li>
        <li><b>Aspect ratio:</b> Square recommended (will be cropped to square)</li>
        </ul>
        <b>Image Processing:</b><br>
        <ul>
        <li>Images are automatically resized to standard dimensions</li>
        <li>Converted to JPEG for consistency and smaller file size</li>
        <li>Multiple sizes may be generated (thumbnail, standard, large)</li>
        <li>Original is not preserved</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>Previous display picture is replaced</li>
        <li>Cached images are invalidated</li>
        <li>CDN cache may take time to update</li>
        </ul>
        <b>Authorization:</b><br>
        Users can only upload their own display picture. Admins cannot upload on behalf of other users.


        :param file: Image file (PNG, JPEG, WebP, or GIF, max 1MB)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UploadUserDisplayPictureRequest(
            file=utils.get_pydantic_model(file, models.UploadUserDisplayPictureFile),
        )

        req = self._build_request(
            method="PUT",
            path="/users/dp",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="image/jpeg",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "multipart",
                models.UploadUserDisplayPictureRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="uploadUserDisplayPicture",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "image/jpeg"):
            return http_res
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = utils.stream_to_text(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def upload_display_picture_async(
        self,
        *,
        file: Union[
            models.UploadUserDisplayPictureFile,
            models.UploadUserDisplayPictureFileTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Upload display picture

        Upload or update the display picture (avatar) for the authenticated user.<br><br>
        <b>Overview:</b><br>
        This endpoint allows users to upload their profile picture. The image is processed, resized, and stored for use throughout the application.<br><br>
        <b>File Requirements:</b><br>
        <ul>
        <li><b>Allowed types:</b> PNG, JPEG, JPG, WebP, GIF</li>
        <li><b>Maximum size:</b> 1MB (1,048,576 bytes)</li>
        <li><b>Recommended dimensions:</b> 256x256 pixels or larger</li>
        <li><b>Aspect ratio:</b> Square recommended (will be cropped to square)</li>
        </ul>
        <b>Image Processing:</b><br>
        <ul>
        <li>Images are automatically resized to standard dimensions</li>
        <li>Converted to JPEG for consistency and smaller file size</li>
        <li>Multiple sizes may be generated (thumbnail, standard, large)</li>
        <li>Original is not preserved</li>
        </ul>
        <b>Side Effects:</b><br>
        <ul>
        <li>Previous display picture is replaced</li>
        <li>Cached images are invalidated</li>
        <li>CDN cache may take time to update</li>
        </ul>
        <b>Authorization:</b><br>
        Users can only upload their own display picture. Admins cannot upload on behalf of other users.


        :param file: Image file (PNG, JPEG, WebP, or GIF, max 1MB)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UploadUserDisplayPictureRequest(
            file=utils.get_pydantic_model(file, models.UploadUserDisplayPictureFile),
        )

        req = self._build_request_async(
            method="PUT",
            path="/users/dp",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="image/jpeg",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "multipart",
                models.UploadUserDisplayPictureRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="uploadUserDisplayPicture",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "image/jpeg"):
            return http_res
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def get_display_picture(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GetDisplayPictureAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUserDisplayPictureResponse:
        r"""Get display picture

        Retrieve the current user's display picture image.<br><br>
        <b>Overview:</b><br>
        This endpoint returns the user's profile picture as binary image data. Use this for displaying the user's avatar in the application.<br><br>
        <b>Response Format:</b><br>
        <ul>
        <li>Returns raw image data (not JSON)</li>
        <li>Content-Type header indicates image format (typically image/jpeg)</li>
        <li>Suitable for use directly in &lt;img&gt; src or CSS background</li>
        </ul>
        <b>Caching:</b><br>
        <ul>
        <li>Response includes cache headers for browser caching</li>
        <li>Use ETag for conditional requests</li>
        <li>Cache invalidated when picture is updated</li>
        </ul>
        <b>Alternative:</b><br>
        For signed URL access, use the user profile endpoint which returns a <code>displayPictureUrl</code> field.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/users/dp",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "image/jpeg;q=1, image/png;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUserDisplayPicture",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "image/jpeg"):
            return http_res
        if utils.match_response(http_res, "200", "image/png"):
            return http_res
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = utils.stream_to_text(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def get_display_picture_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GetDisplayPictureAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetUserDisplayPictureResponse:
        r"""Get display picture

        Retrieve the current user's display picture image.<br><br>
        <b>Overview:</b><br>
        This endpoint returns the user's profile picture as binary image data. Use this for displaying the user's avatar in the application.<br><br>
        <b>Response Format:</b><br>
        <ul>
        <li>Returns raw image data (not JSON)</li>
        <li>Content-Type header indicates image format (typically image/jpeg)</li>
        <li>Suitable for use directly in &lt;img&gt; src or CSS background</li>
        </ul>
        <b>Caching:</b><br>
        <ul>
        <li>Response includes cache headers for browser caching</li>
        <li>Use ETag for conditional requests</li>
        <li>Cache invalidated when picture is updated</li>
        </ul>
        <b>Alternative:</b><br>
        For signed URL access, use the user profile endpoint which returns a <code>displayPictureUrl</code> field.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/users/dp",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "image/jpeg;q=1, image/png;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getUserDisplayPicture",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "image/jpeg"):
            return http_res
        if utils.match_response(http_res, "200", "image/png"):
            return http_res
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def remove_display_picture(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RemoveUserDisplayPictureResponse:
        r"""Remove display picture

        Remove the current user's display picture and revert to default avatar.<br><br>
        <b>Overview:</b><br>
        This endpoint permanently removes the user's uploaded profile picture. After removal, the user will display a default avatar (typically initials or generic icon).<br><br>
        <b>What Happens:</b><br>
        <ul>
        <li>Profile picture file is deleted from storage</li>
        <li>User profile updated to remove picture reference</li>
        <li>Cached images invalidated</li>
        <li>Default avatar will be shown in UI</li>
        </ul>
        <b>Note:</b><br>
        This action is immediate and irreversible. To restore a picture, user must upload a new one.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="DELETE",
            path="/users/dp",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="removeUserDisplayPicture",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.RemoveUserDisplayPictureResponse, http_res
            )
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def remove_display_picture_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RemoveUserDisplayPictureResponse:
        r"""Remove display picture

        Remove the current user's display picture and revert to default avatar.<br><br>
        <b>Overview:</b><br>
        This endpoint permanently removes the user's uploaded profile picture. After removal, the user will display a default avatar (typically initials or generic icon).<br><br>
        <b>What Happens:</b><br>
        <ul>
        <li>Profile picture file is deleted from storage</li>
        <li>User profile updated to remove picture reference</li>
        <li>Cached images invalidated</li>
        <li>Default avatar will be shown in UI</li>
        </ul>
        <b>Note:</b><br>
        This action is immediate and irreversible. To restore a picture, user must upload a new one.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="DELETE",
            path="/users/dp",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="removeUserDisplayPicture",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.RemoveUserDisplayPictureResponse, http_res
            )
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def bulk_invite(
        self,
        *,
        emails: List[str],
        group_ids: Optional[List[str]] = None,
        send_email: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BulkInviteUsersResponse:
        r"""Bulk invite users

        Invite multiple users to the organization in a single operation. Ideal for onboarding entire teams at once.<br><br>
        <b>Overview:</b><br>
        This endpoint creates user accounts for multiple email addresses and sends invitation emails to all of them. It's the most efficient way to add multiple users to your organization.<br><br>
        <b>Invitation Flow:</b><br>
        <ol>
        <li>Validate all email addresses</li>
        <li>Check for existing accounts (skip duplicates)</li>
        <li>Create user accounts for new emails</li>
        <li>Restore any previously deleted accounts</li>
        <li>Add users to specified groups (optional)</li>
        <li>Send invitation emails to all new users</li>
        </ol>
        <b>Requirements:</b><br>
        <ul>
        <li><b>Account Type:</b> Business accounts only (not individual)</li>
        <li><b>SMTP:</b> Email configuration must be set up</li>
        <li><b>Authorization:</b> Admin privileges required</li>
        </ul>
        <b>Email Processing:</b><br>
        <ul>
        <li>Duplicate emails are automatically skipped</li>
        <li>Invalid email formats are rejected</li>
        <li>Existing users are not re-invited (use resend-invite)</li>
        <li>Previously deleted users are restored</li>
        </ul>
        <b>Response Details:</b><br>
        Response includes count of successful invites and any failures with reasons.


        :param emails: Array of email addresses to invite (max 100)
        :param group_ids: Optional group IDs to add all invited users to
        :param send_email: Whether to send invitation emails immediately
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.BulkInviteUsersRequest(
            emails=emails,
            group_ids=group_ids,
            send_email=send_email,
        )

        req = self._build_request(
            method="POST",
            path="/users/bulk/invite",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.BulkInviteUsersRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="bulkInviteUsers",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BulkInviteUsersResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def bulk_invite_async(
        self,
        *,
        emails: List[str],
        group_ids: Optional[List[str]] = None,
        send_email: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BulkInviteUsersResponse:
        r"""Bulk invite users

        Invite multiple users to the organization in a single operation. Ideal for onboarding entire teams at once.<br><br>
        <b>Overview:</b><br>
        This endpoint creates user accounts for multiple email addresses and sends invitation emails to all of them. It's the most efficient way to add multiple users to your organization.<br><br>
        <b>Invitation Flow:</b><br>
        <ol>
        <li>Validate all email addresses</li>
        <li>Check for existing accounts (skip duplicates)</li>
        <li>Create user accounts for new emails</li>
        <li>Restore any previously deleted accounts</li>
        <li>Add users to specified groups (optional)</li>
        <li>Send invitation emails to all new users</li>
        </ol>
        <b>Requirements:</b><br>
        <ul>
        <li><b>Account Type:</b> Business accounts only (not individual)</li>
        <li><b>SMTP:</b> Email configuration must be set up</li>
        <li><b>Authorization:</b> Admin privileges required</li>
        </ul>
        <b>Email Processing:</b><br>
        <ul>
        <li>Duplicate emails are automatically skipped</li>
        <li>Invalid email formats are rejected</li>
        <li>Existing users are not re-invited (use resend-invite)</li>
        <li>Previously deleted users are restored</li>
        </ul>
        <b>Response Details:</b><br>
        Response includes count of successful invites and any failures with reasons.


        :param emails: Array of email addresses to invite (max 100)
        :param group_ids: Optional group IDs to add all invited users to
        :param send_email: Whether to send invitation emails immediately
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.BulkInviteUsersRequest(
            emails=emails,
            group_ids=group_ids,
            send_email=send_email,
        )

        req = self._build_request_async(
            method="POST",
            path="/users/bulk/invite",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.BulkInviteUsersRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="bulkInviteUsers",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BulkInviteUsersResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def resend_invite(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResendUserInviteResponse:
        r"""Resend user invite

        Resend the invitation email to a user who hasn't completed their account setup.<br><br>
        <b>Overview:</b><br>
        This endpoint resends the invitation email to a user who was previously invited but hasn't logged in yet. Useful when the original invitation email was lost, expired, or ended up in spam.<br><br>
        <b>When to Use:</b><br>
        <ul>
        <li>User didn't receive original invitation</li>
        <li>Invitation link expired</li>
        <li>User forgot to complete setup</li>
        <li>Email went to spam folder</li>
        </ul>
        <b>Requirements:</b><br>
        <ul>
        <li>User must exist in the system</li>
        <li>User must NOT have logged in yet (hasLoggedIn: false)</li>
        <li>SMTP configuration must be active</li>
        <li>Admin privileges required</li>
        </ul>
        <b>What Happens:</b><br>
        <ul>
        <li>Generates a new invitation token</li>
        <li>Invalidates any previous invitation links</li>
        <li>Sends new invitation email</li>
        <li>Resets invitation expiry timer</li>
        </ul>


        :param id: User ID of the user to resend invitation to
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ResendUserInviteRequest(
            id=id,
        )

        req = self._build_request(
            method="POST",
            path="/users/{id}/resend-invite",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="resendUserInvite",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ResendUserInviteResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def resend_invite_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResendUserInviteResponse:
        r"""Resend user invite

        Resend the invitation email to a user who hasn't completed their account setup.<br><br>
        <b>Overview:</b><br>
        This endpoint resends the invitation email to a user who was previously invited but hasn't logged in yet. Useful when the original invitation email was lost, expired, or ended up in spam.<br><br>
        <b>When to Use:</b><br>
        <ul>
        <li>User didn't receive original invitation</li>
        <li>Invitation link expired</li>
        <li>User forgot to complete setup</li>
        <li>Email went to spam folder</li>
        </ul>
        <b>Requirements:</b><br>
        <ul>
        <li>User must exist in the system</li>
        <li>User must NOT have logged in yet (hasLoggedIn: false)</li>
        <li>SMTP configuration must be active</li>
        <li>Admin privileges required</li>
        </ul>
        <b>What Happens:</b><br>
        <ul>
        <li>Generates a new invitation token</li>
        <li>Invalidates any previous invitation links</li>
        <li>Sends new invitation email</li>
        <li>Resets invitation expiry timer</li>
        </ul>


        :param id: User ID of the user to resend invitation to
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ResendUserInviteRequest(
            id=id,
        )

        req = self._build_request_async(
            method="POST",
            path="/users/{id}/resend-invite",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="resendUserInvite",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ResendUserInviteResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def list_with_graph(
        self,
        *,
        page: Optional[int] = 1,
        limit: Optional[int] = 10,
        search: Optional[str] = None,
        sort_by: Optional[models.ListUsersGraphSortBy] = "fullName",
        sort_order: Optional[models.ListUsersGraphSortOrder] = "asc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListUsersGraphResponse:
        r"""List users (paginated with graph data)

        Retrieve a paginated list of users with enhanced search capabilities using the graph service.<br><br>
        <b>Overview:</b><br>
        This endpoint provides advanced user listing with full-text search, pagination, and optional relationship data from the knowledge graph. It's optimized for large organizations with thousands of users.<br><br>
        <b>Search Capabilities:</b><br>
        <ul>
        <li>Full-text search across name and email</li>
        <li>Fuzzy matching for typo tolerance</li>
        <li>Results ranked by relevance</li>
        </ul>
        <b>Use Cases:</b><br>
        <ul>
        <li>User directory with search</li>
        <li>Autocomplete user selection</li>
        <li>Admin user management lists</li>
        <li>User analytics dashboards</li>
        </ul>
        <b>Performance:</b><br>
        <ul>
        <li>Powered by graph database for fast queries</li>
        <li>Supports pagination for large datasets</li>
        <li>Results cached for repeated queries</li>
        </ul>
        <b>vs /users endpoint:</b><br>
        Use this endpoint when you need advanced search or are dealing with large user bases. Use <code>/users</code> for simple full-list retrieval.


        :param page: Page number (1-based)
        :param limit: Number of results per page
        :param search: Search query (searches name and email)
        :param sort_by: Field to sort by
        :param sort_order: Sort direction
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListUsersGraphRequest(
            page=page,
            limit=limit,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request(
            method="GET",
            path="/users/graph/list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listUsersGraph",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListUsersGraphResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def list_with_graph_async(
        self,
        *,
        page: Optional[int] = 1,
        limit: Optional[int] = 10,
        search: Optional[str] = None,
        sort_by: Optional[models.ListUsersGraphSortBy] = "fullName",
        sort_order: Optional[models.ListUsersGraphSortOrder] = "asc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListUsersGraphResponse:
        r"""List users (paginated with graph data)

        Retrieve a paginated list of users with enhanced search capabilities using the graph service.<br><br>
        <b>Overview:</b><br>
        This endpoint provides advanced user listing with full-text search, pagination, and optional relationship data from the knowledge graph. It's optimized for large organizations with thousands of users.<br><br>
        <b>Search Capabilities:</b><br>
        <ul>
        <li>Full-text search across name and email</li>
        <li>Fuzzy matching for typo tolerance</li>
        <li>Results ranked by relevance</li>
        </ul>
        <b>Use Cases:</b><br>
        <ul>
        <li>User directory with search</li>
        <li>Autocomplete user selection</li>
        <li>Admin user management lists</li>
        <li>User analytics dashboards</li>
        </ul>
        <b>Performance:</b><br>
        <ul>
        <li>Powered by graph database for fast queries</li>
        <li>Supports pagination for large datasets</li>
        <li>Results cached for repeated queries</li>
        </ul>
        <b>vs /users endpoint:</b><br>
        Use this endpoint when you need advanced search or are dealing with large user bases. Use <code>/users</code> for simple full-list retrieval.


        :param page: Page number (1-based)
        :param limit: Number of results per page
        :param search: Search query (searches name and email)
        :param sort_by: Field to sort by
        :param sort_order: Sort direction
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListUsersGraphRequest(
            page=page,
            limit=limit,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/graph/list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listUsersGraph",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListUsersGraphResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_teams(
        self,
        *,
        page: Optional[int] = None,
        limit: Optional[int] = None,
        search: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Team]:
        r"""Get current user's teams

        Get teams that the current user belongs to

        :param page:
        :param limit:
        :param search:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCurrentUserTeamsRequest(
            page=page,
            limit=limit,
            search=search,
        )

        req = self._build_request(
            method="GET",
            path="/users/teams/list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getCurrentUserTeams",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Team], http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_teams_async(
        self,
        *,
        page: Optional[int] = None,
        limit: Optional[int] = None,
        search: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Team]:
        r"""Get current user's teams

        Get teams that the current user belongs to

        :param page:
        :param limit:
        :param search:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCurrentUserTeamsRequest(
            page=page,
            limit=limit,
            search=search,
        )

        req = self._build_request_async(
            method="GET",
            path="/users/teams/list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getCurrentUserTeams",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Team], http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)
