"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
import httpx
from pipeshub import errors, models, utils
from pipeshub._hooks import HookContext
from pipeshub.types import Nullable, OptionalNullable, UNSET
from pipeshub.utils import get_security_from_env
from pipeshub.utils.unmarshal_json_response import unmarshal_json_response
from typing import Mapping, Optional, Union


class Records(BaseSDK):
    r"""Record management and operations"""

    def get_all(
        self,
        *,
        page: Optional[int] = 1,
        limit: Optional[int] = 20,
        search: Optional[str] = None,
        record_types: Optional[str] = None,
        origins: Optional[models.Origins] = None,
        connectors: Optional[str] = None,
        indexing_status: Optional[str] = None,
        date_from: Optional[int] = None,
        date_to: Optional[int] = None,
        sort_by: Optional[str] = "createdAtTimestamp",
        sort_order: Optional[models.GetAllRecordsSortOrder] = "desc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RecordsResponse:
        r"""Get all records across knowledge bases

        Retrieve records from all knowledge bases accessible to the user.<br><br>
        <b>Overview:</b><br>
        Search and filter records across your entire organization. Useful for global search, reporting, and cross-KB content discovery.<br><br>
        <b>Filtering Options:</b><br>
        <ul>
        <li><b>search:</b> Full-text search in record names</li>
        <li><b>recordTypes:</b> FILE, WEBPAGE, EMAIL, MESSAGE, TICKET, etc.</li>
        <li><b>origins:</b> UPLOAD or CONNECTOR</li>
        <li><b>connectors:</b> Filter by connector source</li>
        <li><b>indexingStatus:</b> COMPLETED, FAILED, IN_PROGRESS, etc.</li>
        <li><b>dateFrom/dateTo:</b> Filter by creation date range</li>
        </ul>
        <b>Response Includes:</b><br>
        <ul>
        <li>Paginated record list</li>
        <li>Applied and available filter counts</li>
        <li>Pagination metadata</li>
        </ul>


        :param page:
        :param limit:
        :param search: Search query (max 1000 chars)
        :param record_types: Filter by record types (comma-separated)
        :param origins: Filter by origin (comma-separated)
        :param connectors: Filter by connector names (comma-separated)
        :param indexing_status: Filter by indexing status (comma-separated)
        :param date_from: Start date filter (Unix timestamp ms)
        :param date_to: End date filter (Unix timestamp ms)
        :param sort_by:
        :param sort_order:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAllRecordsRequest(
            page=page,
            limit=limit,
            search=search,
            record_types=record_types,
            origins=origins,
            connectors=connectors,
            indexing_status=indexing_status,
            date_from=date_from,
            date_to=date_to,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request(
            method="GET",
            path="/knowledgeBase/records",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllRecords",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RecordsResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_all_async(
        self,
        *,
        page: Optional[int] = 1,
        limit: Optional[int] = 20,
        search: Optional[str] = None,
        record_types: Optional[str] = None,
        origins: Optional[models.Origins] = None,
        connectors: Optional[str] = None,
        indexing_status: Optional[str] = None,
        date_from: Optional[int] = None,
        date_to: Optional[int] = None,
        sort_by: Optional[str] = "createdAtTimestamp",
        sort_order: Optional[models.GetAllRecordsSortOrder] = "desc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RecordsResponse:
        r"""Get all records across knowledge bases

        Retrieve records from all knowledge bases accessible to the user.<br><br>
        <b>Overview:</b><br>
        Search and filter records across your entire organization. Useful for global search, reporting, and cross-KB content discovery.<br><br>
        <b>Filtering Options:</b><br>
        <ul>
        <li><b>search:</b> Full-text search in record names</li>
        <li><b>recordTypes:</b> FILE, WEBPAGE, EMAIL, MESSAGE, TICKET, etc.</li>
        <li><b>origins:</b> UPLOAD or CONNECTOR</li>
        <li><b>connectors:</b> Filter by connector source</li>
        <li><b>indexingStatus:</b> COMPLETED, FAILED, IN_PROGRESS, etc.</li>
        <li><b>dateFrom/dateTo:</b> Filter by creation date range</li>
        </ul>
        <b>Response Includes:</b><br>
        <ul>
        <li>Paginated record list</li>
        <li>Applied and available filter counts</li>
        <li>Pagination metadata</li>
        </ul>


        :param page:
        :param limit:
        :param search: Search query (max 1000 chars)
        :param record_types: Filter by record types (comma-separated)
        :param origins: Filter by origin (comma-separated)
        :param connectors: Filter by connector names (comma-separated)
        :param indexing_status: Filter by indexing status (comma-separated)
        :param date_from: Start date filter (Unix timestamp ms)
        :param date_to: End date filter (Unix timestamp ms)
        :param sort_by:
        :param sort_order:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAllRecordsRequest(
            page=page,
            limit=limit,
            search=search,
            record_types=record_types,
            origins=origins,
            connectors=connectors,
            indexing_status=indexing_status,
            date_from=date_from,
            date_to=date_to,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request_async(
            method="GET",
            path="/knowledgeBase/records",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAllRecords",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RecordsResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get(
        self,
        *,
        kb_id: str,
        page: Optional[int] = 1,
        limit: Optional[int] = 20,
        search: Optional[str] = None,
        record_types: Optional[str] = None,
        origins: Optional[str] = None,
        indexing_status: Optional[str] = None,
        date_from: Optional[int] = None,
        date_to: Optional[int] = None,
        sort_by: Optional[str] = "createdAtTimestamp",
        sort_order: Optional[models.GetKBRecordsSortOrder] = "desc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RecordsResponse:
        r"""Get records for a knowledge base

        Retrieve a paginated list of records within a specific knowledge base.<br><br>
        <b>Overview:</b><br>
        Returns all records (documents, files, content) stored in the specified KB, with powerful filtering and sorting capabilities.<br><br>
        <b>Filtering:</b><br>
        <ul>
        <li><b>search:</b> Search by record name (partial match, max 1000 chars)</li>
        <li><b>recordTypes:</b> FILE, WEBPAGE, COMMENT, MESSAGE, EMAIL, TICKET</li>
        <li><b>origins:</b> UPLOAD (manual uploads) or CONNECTOR (synced)</li>
        <li><b>indexingStatus:</b> Filter by processing state</li>
        <li><b>dateFrom/dateTo:</b> Creation date range (Unix timestamps)</li>
        </ul>
        <b>Sorting:</b><br>
        Default sorts by <code>createdAtTimestamp</code> descending (newest first).


        :param kb_id: Knowledge base ID
        :param page:
        :param limit:
        :param search: Search query for record names
        :param record_types: Filter by record types (comma-separated)
        :param origins: Filter by origin
        :param indexing_status: Filter by indexing status
        :param date_from: Start date filter (Unix timestamp)
        :param date_to: End date filter (Unix timestamp)
        :param sort_by:
        :param sort_order:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetKBRecordsRequest(
            kb_id=kb_id,
            page=page,
            limit=limit,
            search=search,
            record_types=record_types,
            origins=origins,
            indexing_status=indexing_status,
            date_from=date_from,
            date_to=date_to,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request(
            method="GET",
            path="/knowledgeBase/{kbId}/records",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getKBRecords",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RecordsResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_async(
        self,
        *,
        kb_id: str,
        page: Optional[int] = 1,
        limit: Optional[int] = 20,
        search: Optional[str] = None,
        record_types: Optional[str] = None,
        origins: Optional[str] = None,
        indexing_status: Optional[str] = None,
        date_from: Optional[int] = None,
        date_to: Optional[int] = None,
        sort_by: Optional[str] = "createdAtTimestamp",
        sort_order: Optional[models.GetKBRecordsSortOrder] = "desc",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RecordsResponse:
        r"""Get records for a knowledge base

        Retrieve a paginated list of records within a specific knowledge base.<br><br>
        <b>Overview:</b><br>
        Returns all records (documents, files, content) stored in the specified KB, with powerful filtering and sorting capabilities.<br><br>
        <b>Filtering:</b><br>
        <ul>
        <li><b>search:</b> Search by record name (partial match, max 1000 chars)</li>
        <li><b>recordTypes:</b> FILE, WEBPAGE, COMMENT, MESSAGE, EMAIL, TICKET</li>
        <li><b>origins:</b> UPLOAD (manual uploads) or CONNECTOR (synced)</li>
        <li><b>indexingStatus:</b> Filter by processing state</li>
        <li><b>dateFrom/dateTo:</b> Creation date range (Unix timestamps)</li>
        </ul>
        <b>Sorting:</b><br>
        Default sorts by <code>createdAtTimestamp</code> descending (newest first).


        :param kb_id: Knowledge base ID
        :param page:
        :param limit:
        :param search: Search query for record names
        :param record_types: Filter by record types (comma-separated)
        :param origins: Filter by origin
        :param indexing_status: Filter by indexing status
        :param date_from: Start date filter (Unix timestamp)
        :param date_to: End date filter (Unix timestamp)
        :param sort_by:
        :param sort_order:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetKBRecordsRequest(
            kb_id=kb_id,
            page=page,
            limit=limit,
            search=search,
            record_types=record_types,
            origins=origins,
            indexing_status=indexing_status,
            date_from=date_from,
            date_to=date_to,
            sort_by=sort_by,
            sort_order=sort_order,
        )

        req = self._build_request_async(
            method="GET",
            path="/knowledgeBase/{kbId}/records",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getKBRecords",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RecordsResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def get_by_id(
        self,
        *,
        record_id: str,
        convert_to: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Record:
        r"""Get record by ID

        Retrieve detailed information about a specific record.<br><br>
        <b>Overview:</b><br>
        Returns complete record metadata including name, type, indexing status, storage information, and version history.<br><br>
        <b>File Conversion:</b><br>
        Use the optional <code>convertTo</code> parameter to request file format conversion (e.g., PDF to text).


        :param record_id: Record ID
        :param convert_to: Optional format to convert the file to
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetRecordByIDRequest(
            record_id=record_id,
            convert_to=convert_to,
        )

        req = self._build_request(
            method="GET",
            path="/knowledgeBase/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getRecordById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Record, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def get_by_id_async(
        self,
        *,
        record_id: str,
        convert_to: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Record:
        r"""Get record by ID

        Retrieve detailed information about a specific record.<br><br>
        <b>Overview:</b><br>
        Returns complete record metadata including name, type, indexing status, storage information, and version history.<br><br>
        <b>File Conversion:</b><br>
        Use the optional <code>convertTo</code> parameter to request file format conversion (e.g., PDF to text).


        :param record_id: Record ID
        :param convert_to: Optional format to convert the file to
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetRecordByIDRequest(
            record_id=record_id,
            convert_to=convert_to,
        )

        req = self._build_request_async(
            method="GET",
            path="/knowledgeBase/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getRecordById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Record, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def update(
        self,
        *,
        record_id: str,
        record_name: Optional[str] = None,
        file: Optional[
            Union[models.UpdateRecordFile, models.UpdateRecordFileTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateRecordResponse:
        r"""Update record

        Update a record's name and/or file content.<br><br>
        <b>Overview:</b><br>
        Allows updating the display name and optionally replacing the file content. Triggers re-indexing when content changes.<br><br>
        <b>Required Permission:</b> WRITER or higher<br><br>
        <b>Updating File Content:</b><br>
        Include a new file in the request to replace the existing content. The file extension must match the original.<br><br>
        <b>Side Effects:</b><br>
        <ul>
        <li>Updates <code>updatedAtTimestamp</code></li>
        <li>Increments version if file content changed</li>
        <li>Triggers re-indexing for content changes</li>
        </ul>


        :param record_id: Record ID
        :param record_name: New name for the record
        :param file: Replacement file content
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateRecordRequest(
            record_id=record_id,
            body=models.UpdateRecordRequestBody(
                record_name=record_name,
                file=utils.get_pydantic_model(file, Optional[models.UpdateRecordFile]),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/knowledgeBase/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                True,
                "multipart",
                Optional[models.UpdateRecordRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateRecord",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateRecordResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        record_id: str,
        record_name: Optional[str] = None,
        file: Optional[
            Union[models.UpdateRecordFile, models.UpdateRecordFileTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateRecordResponse:
        r"""Update record

        Update a record's name and/or file content.<br><br>
        <b>Overview:</b><br>
        Allows updating the display name and optionally replacing the file content. Triggers re-indexing when content changes.<br><br>
        <b>Required Permission:</b> WRITER or higher<br><br>
        <b>Updating File Content:</b><br>
        Include a new file in the request to replace the existing content. The file extension must match the original.<br><br>
        <b>Side Effects:</b><br>
        <ul>
        <li>Updates <code>updatedAtTimestamp</code></li>
        <li>Increments version if file content changed</li>
        <li>Triggers re-indexing for content changes</li>
        </ul>


        :param record_id: Record ID
        :param record_name: New name for the record
        :param file: Replacement file content
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateRecordRequest(
            record_id=record_id,
            body=models.UpdateRecordRequestBody(
                record_name=record_name,
                file=utils.get_pydantic_model(file, Optional[models.UpdateRecordFile]),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/knowledgeBase/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body,
                False,
                True,
                "multipart",
                Optional[models.UpdateRecordRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateRecord",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UpdateRecordResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        record_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete record

        Permanently delete a record from the knowledge base.<br><br>
        <b>Required Permission:</b> WRITER or higher<br><br>
        <b>What Gets Deleted:</b><br>
        <ul>
        <li>Record metadata</li>
        <li>Associated storage file</li>
        <li>Indexed content and embeddings</li>
        </ul>
        <b>Warning:</b> This action is irreversible.


        :param record_id: Record ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteRecordRequest(
            record_id=record_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/knowledgeBase/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteRecord",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        record_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete record

        Permanently delete a record from the knowledge base.<br><br>
        <b>Required Permission:</b> WRITER or higher<br><br>
        <b>What Gets Deleted:</b><br>
        <ul>
        <li>Record metadata</li>
        <li>Associated storage file</li>
        <li>Indexed content and embeddings</li>
        </ul>
        <b>Warning:</b> This action is irreversible.


        :param record_id: Record ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteRecordRequest(
            record_id=record_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/knowledgeBase/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteRecord",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def stream(
        self,
        *,
        record_id: str,
        convert_to: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Stream record content

        Stream the binary content of a record's file.<br><br>
        <b>Overview:</b><br>
        Returns the raw file content with appropriate Content-Type and Content-Disposition headers for download or inline viewing.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>File downloads</li>
        <li>Inline document preview</li>
        <li>Content extraction pipelines</li>
        </ul>
        <b>Format Conversion:</b><br>
        Use <code>convertTo</code> parameter to convert between formats (e.g., DOCX to PDF).


        :param record_id: Record ID
        :param convert_to: Target format for conversion
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamRecordBufferRequest(
            record_id=record_id,
            convert_to=convert_to,
        )

        req = self._build_request(
            method="GET",
            path="/knowledgeBase/stream/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/octet-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="streamRecordBuffer",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/octet-stream"):
            return http_res
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = utils.stream_to_text(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def stream_async(
        self,
        *,
        record_id: str,
        convert_to: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Stream record content

        Stream the binary content of a record's file.<br><br>
        <b>Overview:</b><br>
        Returns the raw file content with appropriate Content-Type and Content-Disposition headers for download or inline viewing.<br><br>
        <b>Use Cases:</b><br>
        <ul>
        <li>File downloads</li>
        <li>Inline document preview</li>
        <li>Content extraction pipelines</li>
        </ul>
        <b>Format Conversion:</b><br>
        Use <code>convertTo</code> parameter to convert between formats (e.g., DOCX to PDF).


        :param record_id: Record ID
        :param convert_to: Target format for conversion
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamRecordBufferRequest(
            record_id=record_id,
            convert_to=convert_to,
        )

        req = self._build_request_async(
            method="GET",
            path="/knowledgeBase/stream/record/{recordId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/octet-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="streamRecordBuffer",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/octet-stream"):
            return http_res
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.PipeshubDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def move(
        self,
        *,
        kb_id: str,
        record_id: str,
        new_parent_id: Nullable[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Move a record to another folder

        Move a record (file or folder) to a different parent folder within the same knowledge base.<br><br>
        <b>Required Permission:</b> WRITER or higher<br><br>
        <b>Moving to Root:</b><br>
        Set <code>newParentId</code> to <code>null</code> to move the record to the root level of the knowledge base.


        :param kb_id: Knowledge base ID
        :param record_id: Record ID to move
        :param new_parent_id: ID of the new parent folder, or null to move to root level
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.MoveRecordRequest(
            kb_id=kb_id,
            record_id=record_id,
            body=models.MoveRecordRequestBody(
                new_parent_id=new_parent_id,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/knowledgeBase/{kbId}/record/{recordId}/move",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.MoveRecordRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="moveRecord",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def move_async(
        self,
        *,
        kb_id: str,
        record_id: str,
        new_parent_id: Nullable[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Move a record to another folder

        Move a record (file or folder) to a different parent folder within the same knowledge base.<br><br>
        <b>Required Permission:</b> WRITER or higher<br><br>
        <b>Moving to Root:</b><br>
        Set <code>newParentId</code> to <code>null</code> to move the record to the root level of the knowledge base.


        :param kb_id: Knowledge base ID
        :param record_id: Record ID to move
        :param new_parent_id: ID of the new parent folder, or null to move to root level
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.MoveRecordRequest(
            kb_id=kb_id,
            record_id=record_id,
            body=models.MoveRecordRequestBody(
                new_parent_id=new_parent_id,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/knowledgeBase/{kbId}/record/{recordId}/move",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.MoveRecordRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="moveRecord",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)
