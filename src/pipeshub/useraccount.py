"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from pipeshub import errors, models, utils
from pipeshub._hooks import HookContext
from pipeshub.types import OptionalNullable, UNSET
from pipeshub.utils import get_security_from_env
from pipeshub.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Mapping, Optional, Union


class UserAccount(BaseSDK):
    def init_auth(
        self,
        *,
        email: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.InitAuthResponseResponse:
        r"""Initialize authentication session

        Initialize an authentication session for a user by email address.
        This is the first step in the multi-step authentication flow.
        <br><br>
        <b>Flow:</b><br>
        1. Call this endpoint with the user's email<br>
        2. Receive a session token in the <code>x-session-token</code> response header<br>
        3. Use the session token in subsequent <code>/authenticate</code> calls<br>
        4. The response includes <code>allowedMethods</code> for the first authentication step
        <br><br>
        <b>Session Token:</b><br>
        - Stored in response header <code>x-session-token</code><br>
        - Required for all subsequent authentication requests<br>
        - Expires after a configured timeout period
        <br><br>
        <b>Multi-Factor Authentication:</b><br>
        If the organization has MFA configured, you'll need to complete multiple
        authentication steps. Each step completion returns the next step's allowed methods.


        :param email: User email address (RFC 5321 compliant)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.InitAuthRequest(
            email=email,
        )

        req = self._build_request(
            method="POST",
            path="/userAccount/initAuth",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.InitAuthRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="initAuth",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.InitAuthResponseResponse(
                result=unmarshal_json_response(models.InitAuthResponse, http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def init_auth_async(
        self,
        *,
        email: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.InitAuthResponseResponse:
        r"""Initialize authentication session

        Initialize an authentication session for a user by email address.
        This is the first step in the multi-step authentication flow.
        <br><br>
        <b>Flow:</b><br>
        1. Call this endpoint with the user's email<br>
        2. Receive a session token in the <code>x-session-token</code> response header<br>
        3. Use the session token in subsequent <code>/authenticate</code> calls<br>
        4. The response includes <code>allowedMethods</code> for the first authentication step
        <br><br>
        <b>Session Token:</b><br>
        - Stored in response header <code>x-session-token</code><br>
        - Required for all subsequent authentication requests<br>
        - Expires after a configured timeout period
        <br><br>
        <b>Multi-Factor Authentication:</b><br>
        If the organization has MFA configured, you'll need to complete multiple
        authentication steps. Each step completion returns the next step's allowed methods.


        :param email: User email address (RFC 5321 compliant)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.InitAuthRequest(
            email=email,
        )

        req = self._build_request_async(
            method="POST",
            path="/userAccount/initAuth",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.InitAuthRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="initAuth",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.InitAuthResponseResponse(
                result=unmarshal_json_response(models.InitAuthResponse, http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def authenticate(
        self,
        *,
        x_session_token: str,
        method: models.Method,
        credentials: Union[models.Credentials, models.CredentialsTypedDict],
        email: Optional[str] = None,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AuthenticateResponse:
        r"""Authenticate user with credentials

        Authenticate a user using the specified method and credentials.
        Requires a valid session token from <code>/initAuth</code>.
        <br><br>
        <b>Credential Formats by Method:</b><br>
        - <code>password</code>: <code>{ \"credentials\": { \"password\": \"your-password\" } }</code><br>
        - <code>otp</code>: <code>{ \"credentials\": { \"otp\": \"123456\" } }</code> (6-digit code, valid for 10 minutes)<br>
        - <code>google</code>: <code>{ \"credentials\": \"google-id-token-string\" }</code><br>
        - <code>microsoft</code>: <code>{ \"credentials\": { \"accessToken\": \"...\", \"idToken\": \"...\" } }</code><br>
        - <code>azureAd</code>: <code>{ \"credentials\": { \"accessToken\": \"...\", \"idToken\": \"...\" } }</code><br>
        - <code>oauth</code>: <code>{ \"credentials\": { \"accessToken\": \"...\", \"idToken\": \"...\" } }</code><br>
        - <code>samlSso</code>: Handled via redirect flow (use <code>/saml/signIn</code> instead)
        <br><br>
        <b>Multi-Step Response:</b><br>
        If organization uses MFA, successful authentication returns:<br>
        - <code>status: \"success\"</code> with <code>nextStep</code> and <code>allowedMethods</code> for next step
        <br><br>
        <b>Fully Authenticated Response:</b><br>
        After completing all steps:<br>
        - <code>message: \"Fully authenticated\"</code> with <code>accessToken</code> (1hr) and <code>refreshToken</code> (7d)
        <br><br>
        <b>Security:</b><br>
        - Account locks after 5 consecutive failed attempts<br>
        - CAPTCHA may be required if enabled (pass <code>cf-turnstile-response</code>)


        :param x_session_token: Session token received from `/initAuth` endpoint
        :param method: Authentication method to use
        :param credentials: Credentials based on the authentication method
        :param email: Optional email for verification (used with some OAuth methods)
        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional, if CAPTCHA is enabled)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AuthenticateRequestRequest(
            x_session_token=x_session_token,
            body=models.AuthenticateRequest(
                method=method,
                credentials=utils.get_pydantic_model(credentials, models.Credentials),
                email=email,
                cf_turnstile_response=cf_turnstile_response,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/userAccount/authenticate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.AuthenticateRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="authenticate",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "410", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AuthenticateResponse, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "410"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def authenticate_async(
        self,
        *,
        x_session_token: str,
        method: models.Method,
        credentials: Union[models.Credentials, models.CredentialsTypedDict],
        email: Optional[str] = None,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AuthenticateResponse:
        r"""Authenticate user with credentials

        Authenticate a user using the specified method and credentials.
        Requires a valid session token from <code>/initAuth</code>.
        <br><br>
        <b>Credential Formats by Method:</b><br>
        - <code>password</code>: <code>{ \"credentials\": { \"password\": \"your-password\" } }</code><br>
        - <code>otp</code>: <code>{ \"credentials\": { \"otp\": \"123456\" } }</code> (6-digit code, valid for 10 minutes)<br>
        - <code>google</code>: <code>{ \"credentials\": \"google-id-token-string\" }</code><br>
        - <code>microsoft</code>: <code>{ \"credentials\": { \"accessToken\": \"...\", \"idToken\": \"...\" } }</code><br>
        - <code>azureAd</code>: <code>{ \"credentials\": { \"accessToken\": \"...\", \"idToken\": \"...\" } }</code><br>
        - <code>oauth</code>: <code>{ \"credentials\": { \"accessToken\": \"...\", \"idToken\": \"...\" } }</code><br>
        - <code>samlSso</code>: Handled via redirect flow (use <code>/saml/signIn</code> instead)
        <br><br>
        <b>Multi-Step Response:</b><br>
        If organization uses MFA, successful authentication returns:<br>
        - <code>status: \"success\"</code> with <code>nextStep</code> and <code>allowedMethods</code> for next step
        <br><br>
        <b>Fully Authenticated Response:</b><br>
        After completing all steps:<br>
        - <code>message: \"Fully authenticated\"</code> with <code>accessToken</code> (1hr) and <code>refreshToken</code> (7d)
        <br><br>
        <b>Security:</b><br>
        - Account locks after 5 consecutive failed attempts<br>
        - CAPTCHA may be required if enabled (pass <code>cf-turnstile-response</code>)


        :param x_session_token: Session token received from `/initAuth` endpoint
        :param method: Authentication method to use
        :param credentials: Credentials based on the authentication method
        :param email: Optional email for verification (used with some OAuth methods)
        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional, if CAPTCHA is enabled)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AuthenticateRequestRequest(
            x_session_token=x_session_token,
            body=models.AuthenticateRequest(
                method=method,
                credentials=utils.get_pydantic_model(credentials, models.Credentials),
                email=email,
                cf_turnstile_response=cf_turnstile_response,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/userAccount/authenticate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.AuthenticateRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="authenticate",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "410", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AuthenticateResponse, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "410"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def generate_otp(
        self,
        *,
        email: str,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GenerateLoginOtpResponse:
        r"""Generate and send OTP for login

        Generate and send a 6-digit one-time password (OTP) to the user's email.
        Use this endpoint before authenticating with the <code>otp</code> method.
        <br><br>
        <b>OTP Details:</b><br>
        - 6 digits numeric code<br>
        - Valid for <b>10 minutes</b> after generation<br>
        - Sent to user's registered email address
        <br><br>
        <b>Rate Limiting:</b><br>
        - Multiple OTP requests may be rate-limited<br>
        - Wait for the current OTP to expire before requesting a new one
        <br><br>
        <b>CAPTCHA:</b><br>
        If Cloudflare Turnstile is enabled, include <code>cf-turnstile-response</code> in the request body.


        :param email: Email address to send OTP to
        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OtpGenerateRequest(
            email=email,
            cf_turnstile_response=cf_turnstile_response,
        )

        req = self._build_request(
            method="POST",
            path="/userAccount/login/otp/generate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.OtpGenerateRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="generateLoginOtp",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GenerateLoginOtpResponse, http_res)
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, ["429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def generate_otp_async(
        self,
        *,
        email: str,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GenerateLoginOtpResponse:
        r"""Generate and send OTP for login

        Generate and send a 6-digit one-time password (OTP) to the user's email.
        Use this endpoint before authenticating with the <code>otp</code> method.
        <br><br>
        <b>OTP Details:</b><br>
        - 6 digits numeric code<br>
        - Valid for <b>10 minutes</b> after generation<br>
        - Sent to user's registered email address
        <br><br>
        <b>Rate Limiting:</b><br>
        - Multiple OTP requests may be rate-limited<br>
        - Wait for the current OTP to expire before requesting a new one
        <br><br>
        <b>CAPTCHA:</b><br>
        If Cloudflare Turnstile is enabled, include <code>cf-turnstile-response</code> in the request body.


        :param email: Email address to send OTP to
        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OtpGenerateRequest(
            email=email,
            cf_turnstile_response=cf_turnstile_response,
        )

        req = self._build_request_async(
            method="POST",
            path="/userAccount/login/otp/generate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.OtpGenerateRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="generateLoginOtp",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GenerateLoginOtpResponse, http_res)
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, ["429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def reset_password(
        self,
        *,
        current_password: str,
        new_password: str,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PasswordResetResponse:
        r"""Reset password (authenticated user)

        Reset password for an authenticated user. Requires the current password for verification.
        <br><br>
        <b>Password Requirements:</b><br>
        - Minimum 8 characters<br>
        - At least 1 uppercase letter (A-Z)<br>
        - At least 1 lowercase letter (a-z)<br>
        - At least 1 number (0-9)<br>
        - At least 1 special character (#?!@$%^&*-)
        <br><br>
        <b>Security Notes:</b><br>
        - A new access token is returned (old tokens are invalidated)<br>
        - CAPTCHA may be required if enabled (pass <code>cf-turnstile-response</code>)


        :param current_password: Current password for verification
        :param new_password: New password. Must meet the following requirements:
            - Minimum 8 characters
            - At least 1 uppercase letter
            - At least 1 lowercase letter
            - At least 1 number
            - At least 1 special character (#?!@$%^&*-)

        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PasswordResetRequest(
            current_password=current_password,
            new_password=new_password,
            cf_turnstile_response=cf_turnstile_response,
        )

        req = self._build_request(
            method="POST",
            path="/userAccount/password/reset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PasswordResetRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="resetPassword",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PasswordResetResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def reset_password_async(
        self,
        *,
        current_password: str,
        new_password: str,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PasswordResetResponse:
        r"""Reset password (authenticated user)

        Reset password for an authenticated user. Requires the current password for verification.
        <br><br>
        <b>Password Requirements:</b><br>
        - Minimum 8 characters<br>
        - At least 1 uppercase letter (A-Z)<br>
        - At least 1 lowercase letter (a-z)<br>
        - At least 1 number (0-9)<br>
        - At least 1 special character (#?!@$%^&*-)
        <br><br>
        <b>Security Notes:</b><br>
        - A new access token is returned (old tokens are invalidated)<br>
        - CAPTCHA may be required if enabled (pass <code>cf-turnstile-response</code>)


        :param current_password: Current password for verification
        :param new_password: New password. Must meet the following requirements:
            - Minimum 8 characters
            - At least 1 uppercase letter
            - At least 1 lowercase letter
            - At least 1 number
            - At least 1 special character (#?!@$%^&*-)

        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PasswordResetRequest(
            current_password=current_password,
            new_password=new_password,
            cf_turnstile_response=cf_turnstile_response,
        )

        req = self._build_request_async(
            method="POST",
            path="/userAccount/password/reset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PasswordResetRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="resetPassword",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PasswordResetResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def forgot_password(
        self,
        *,
        email: str,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ForgotPasswordResponse:
        r"""Request password reset email

        Send a password reset link to the user's email.
        The link contains a time-limited token that can be used to reset the password.
        <br><br>
        <b>Note:</b> This endpoint always returns 200 even if the email doesn't exist (to prevent email enumeration).


        :param email: Email address to send reset link to
        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ForgotPasswordRequest(
            email=email,
            cf_turnstile_response=cf_turnstile_response,
        )

        req = self._build_request(
            method="POST",
            path="/userAccount/password/forgot",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.ForgotPasswordRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="forgotPassword",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ForgotPasswordResponse, http_res)
        if utils.match_response(http_res, ["400", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def forgot_password_async(
        self,
        *,
        email: str,
        cf_turnstile_response: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ForgotPasswordResponse:
        r"""Request password reset email

        Send a password reset link to the user's email.
        The link contains a time-limited token that can be used to reset the password.
        <br><br>
        <b>Note:</b> This endpoint always returns 200 even if the email doesn't exist (to prevent email enumeration).


        :param email: Email address to send reset link to
        :param cf_turnstile_response: Cloudflare Turnstile CAPTCHA token (optional)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ForgotPasswordRequest(
            email=email,
            cf_turnstile_response=cf_turnstile_response,
        )

        req = self._build_request_async(
            method="POST",
            path="/userAccount/password/forgot",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=False,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.ForgotPasswordRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="forgotPassword",
                oauth2_scopes=None,
                security_source=None,
            ),
            request=req,
            error_status_codes=["400", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ForgotPasswordResponse, http_res)
        if utils.match_response(http_res, ["400", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def reset_password_token(
        self,
        *,
        security: Union[
            models.ResetPasswordWithTokenSecurity,
            models.ResetPasswordWithTokenSecurityTypedDict,
        ],
        password: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PasswordResetResponse:
        r"""Reset password with email token

        Reset password using a token received via email from the forgot password flow.
        <br><br>
        <b>Password Requirements:</b><br>
        - Minimum 8 characters<br>
        - At least 1 uppercase letter<br>
        - At least 1 lowercase letter<br>
        - At least 1 number<br>
        - At least 1 special character (#?!@$%^&*-)
        <br><br>
        <b>Security Notes:</b><br>
        - Token is single-use and expires after a set time<br>
        - A new access token is returned upon successful reset


        :param security:
        :param password: New password (must meet password requirements)

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TokenPasswordResetRequest(
            password=password,
        )

        req = self._build_request(
            method="POST",
            path="/userAccount/password/reset/token",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.ResetPasswordWithTokenSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TokenPasswordResetRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="resetPasswordWithToken",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PasswordResetResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def reset_password_token_async(
        self,
        *,
        security: Union[
            models.ResetPasswordWithTokenSecurity,
            models.ResetPasswordWithTokenSecurityTypedDict,
        ],
        password: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PasswordResetResponse:
        r"""Reset password with email token

        Reset password using a token received via email from the forgot password flow.
        <br><br>
        <b>Password Requirements:</b><br>
        - Minimum 8 characters<br>
        - At least 1 uppercase letter<br>
        - At least 1 lowercase letter<br>
        - At least 1 number<br>
        - At least 1 special character (#?!@$%^&*-)
        <br><br>
        <b>Security Notes:</b><br>
        - Token is single-use and expires after a set time<br>
        - A new access token is returned upon successful reset


        :param security:
        :param password: New password (must meet password requirements)

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TokenPasswordResetRequest(
            password=password,
        )

        req = self._build_request_async(
            method="POST",
            path="/userAccount/password/reset/token",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.ResetPasswordWithTokenSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TokenPasswordResetRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="resetPasswordWithToken",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PasswordResetResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def check_password_set(
        self,
        *,
        security: Union[
            models.CheckPasswordStatusSecurity,
            models.CheckPasswordStatusSecurityTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CheckPasswordStatusResponse:
        r"""Check if user has password set (Internal)

        Internal endpoint to check if a user has a password configured.
        Used by other services to determine authentication capabilities.
        <br><br>
        <b>Note:</b> This is an internal service-to-service endpoint.


        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/userAccount/internal/password/check",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CheckPasswordStatusSecurity
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="checkPasswordStatus",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CheckPasswordStatusResponse, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def check_password_set_async(
        self,
        *,
        security: Union[
            models.CheckPasswordStatusSecurity,
            models.CheckPasswordStatusSecurityTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CheckPasswordStatusResponse:
        r"""Check if user has password set (Internal)

        Internal endpoint to check if a user has a password configured.
        Used by other services to determine authentication capabilities.
        <br><br>
        <b>Note:</b> This is an internal service-to-service endpoint.


        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/userAccount/internal/password/check",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CheckPasswordStatusSecurity
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="checkPasswordStatus",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CheckPasswordStatusResponse, http_res)
        if utils.match_response(http_res, ["401", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def refresh(
        self,
        *,
        security: Union[
            models.RefreshTokenSecurity, models.RefreshTokenSecurityTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RefreshTokenResponse:
        r"""Refresh access token

        Get a new access token using a valid refresh token.
        <br><br>
        <b>Usage:</b><br>
        - Pass the refresh token as a Bearer token in the Authorization header<br>
        - Returns a new access token (1 hour expiry) and basic user information
        <br><br>
        <b>Token Lifetimes:</b><br>
        - Access token: 1 hour<br>
        - Refresh token: 7 days
        <br><br>
        <b>Best Practices:</b><br>
        - Call this endpoint before the access token expires<br>
        - Store the new access token and continue using it for authenticated requests<br>
        - If refresh fails with 401, redirect user to login flow


        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="POST",
            path="/userAccount/refresh/token",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.RefreshTokenSecurity),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="refreshToken",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RefreshTokenResponse, http_res)
        if utils.match_response(http_res, ["401", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def refresh_async(
        self,
        *,
        security: Union[
            models.RefreshTokenSecurity, models.RefreshTokenSecurityTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RefreshTokenResponse:
        r"""Refresh access token

        Get a new access token using a valid refresh token.
        <br><br>
        <b>Usage:</b><br>
        - Pass the refresh token as a Bearer token in the Authorization header<br>
        - Returns a new access token (1 hour expiry) and basic user information
        <br><br>
        <b>Token Lifetimes:</b><br>
        - Access token: 1 hour<br>
        - Refresh token: 7 days
        <br><br>
        <b>Best Practices:</b><br>
        - Call this endpoint before the access token expires<br>
        - Store the new access token and continue using it for authenticated requests<br>
        - If refresh fails with 401, redirect user to login flow


        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="POST",
            path="/userAccount/refresh/token",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.RefreshTokenSecurity),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="refreshToken",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["401", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RefreshTokenResponse, http_res)
        if utils.match_response(http_res, ["401", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.AuthErrorData, http_res)
            raise errors.AuthError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    def logout(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.LogoutResponse:
        r"""Logout current session

        Log out the current user session and invalidate tokens.
        <br><br>
        <b>Effects:</b><br>
        - Invalidates the current access token<br>
        - Clears server-side session data<br>
        - Client should also clear stored tokens locally
        <br><br>
        <b>Note:</b> This endpoint requires the access token, not the refresh token.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="POST",
            path="/userAccount/logout/manual",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="logout",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.LogoutResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)

    async def logout_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.LogoutResponse:
        r"""Logout current session

        Log out the current user session and invalidate tokens.
        <br><br>
        <b>Effects:</b><br>
        - Invalidates the current access token<br>
        - Clears server-side session data<br>
        - Client should also clear stored tokens locally
        <br><br>
        <b>Note:</b> This endpoint requires the access token, not the refresh token.


        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="POST",
            path="/userAccount/logout/manual",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="logout",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.LogoutResponse, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.PipeshubDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.PipeshubDefaultError("Unexpected response received", http_res)
