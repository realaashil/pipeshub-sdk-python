"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .citationreference import CitationReference, CitationReferenceTypedDict
from .followupquestion import FollowUpQuestion, FollowUpQuestionTypedDict
from .messagefeedback import MessageFeedback, MessageFeedbackTypedDict
from datetime import datetime
from pipeshub.types import BaseModel, UNSET_SENTINEL, UnrecognizedStr
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


MessageType = Union[
    Literal[
        "user_query",
        "bot_response",
        "error",
        "feedback",
        "system",
    ],
    UnrecognizedStr,
]
r"""Type of message:
<ul>
<li><code>user_query</code> - User's question or input</li>
<li><code>bot_response</code> - AI-generated response</li>
<li><code>error</code> - Error message from the system</li>
<li><code>feedback</code> - User feedback on a response</li>
<li><code>system</code> - System notification or status</li>
</ul>

"""


ContentFormat = Union[
    Literal[
        "MARKDOWN",
        "JSON",
        "HTML",
    ],
    UnrecognizedStr,
]
r"""Format of the content for rendering"""


class MessageMetadataTypedDict(TypedDict):
    processing_time_ms: NotRequired[float]
    r"""Time taken to generate response in milliseconds"""
    model_version: NotRequired[str]
    r"""Version of the AI model used"""
    ai_transaction_id: NotRequired[str]
    r"""Transaction ID for tracking in AI backend"""
    reason: NotRequired[str]
    r"""Additional context or reasoning"""


class MessageMetadata(BaseModel):
    processing_time_ms: Annotated[
        Optional[float], pydantic.Field(alias="processingTimeMs")
    ] = None
    r"""Time taken to generate response in milliseconds"""

    model_version: Annotated[Optional[str], pydantic.Field(alias="modelVersion")] = None
    r"""Version of the AI model used"""

    ai_transaction_id: Annotated[
        Optional[str], pydantic.Field(alias="aiTransactionId")
    ] = None
    r"""Transaction ID for tracking in AI backend"""

    reason: Optional[str] = None
    r"""Additional context or reasoning"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["processingTimeMs", "modelVersion", "aiTransactionId", "reason"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class MessageTypedDict(TypedDict):
    r"""A single message within a conversation. Messages can be user queries,
    AI responses, system messages, or error notifications.

    """

    id: NotRequired[str]
    r"""Unique message identifier"""
    message_type: NotRequired[MessageType]
    r"""Type of message:
    <ul>
    <li><code>user_query</code> - User's question or input</li>
    <li><code>bot_response</code> - AI-generated response</li>
    <li><code>error</code> - Error message from the system</li>
    <li><code>feedback</code> - User feedback on a response</li>
    <li><code>system</code> - System notification or status</li>
    </ul>

    """
    content: NotRequired[str]
    r"""The message text content"""
    content_format: NotRequired[ContentFormat]
    r"""Format of the content for rendering"""
    citations: NotRequired[List[CitationReferenceTypedDict]]
    r"""References to source documents used in the response"""
    confidence: NotRequired[str]
    r"""AI's confidence level in the response"""
    follow_up_questions: NotRequired[List[FollowUpQuestionTypedDict]]
    r"""Suggested follow-up questions"""
    feedback: NotRequired[List[MessageFeedbackTypedDict]]
    r"""User feedback on this message"""
    metadata: NotRequired[MessageMetadataTypedDict]
    created_at: NotRequired[datetime]
    updated_at: NotRequired[datetime]


class Message(BaseModel):
    r"""A single message within a conversation. Messages can be user queries,
    AI responses, system messages, or error notifications.

    """

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None
    r"""Unique message identifier"""

    message_type: Annotated[
        Optional[MessageType], pydantic.Field(alias="messageType")
    ] = None
    r"""Type of message:
    <ul>
    <li><code>user_query</code> - User's question or input</li>
    <li><code>bot_response</code> - AI-generated response</li>
    <li><code>error</code> - Error message from the system</li>
    <li><code>feedback</code> - User feedback on a response</li>
    <li><code>system</code> - System notification or status</li>
    </ul>

    """

    content: Optional[str] = None
    r"""The message text content"""

    content_format: Annotated[
        Optional[ContentFormat], pydantic.Field(alias="contentFormat")
    ] = "MARKDOWN"
    r"""Format of the content for rendering"""

    citations: Optional[List[CitationReference]] = None
    r"""References to source documents used in the response"""

    confidence: Optional[str] = None
    r"""AI's confidence level in the response"""

    follow_up_questions: Annotated[
        Optional[List[FollowUpQuestion]], pydantic.Field(alias="followUpQuestions")
    ] = None
    r"""Suggested follow-up questions"""

    feedback: Optional[List[MessageFeedback]] = None
    r"""User feedback on this message"""

    metadata: Optional[MessageMetadata] = None

    created_at: Annotated[Optional[datetime], pydantic.Field(alias="createdAt")] = None

    updated_at: Annotated[Optional[datetime], pydantic.Field(alias="updatedAt")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_id",
                "messageType",
                "content",
                "contentFormat",
                "citations",
                "confidence",
                "followUpQuestions",
                "feedback",
                "metadata",
                "createdAt",
                "updatedAt",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    MessageMetadata.model_rebuild()
except NameError:
    pass
try:
    Message.model_rebuild()
except NameError:
    pass
