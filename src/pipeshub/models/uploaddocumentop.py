"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .document import Document, DocumentTypedDict
import io
from pipeshub.types import BaseModel, UNSET_SENTINEL
from pipeshub.utils import FieldMetadata, MultipartFormMetadata
import pydantic
from pydantic import model_serializer
from typing import Dict, IO, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


UploadDocumentPermissions = Literal[
    "owner",
    "editor",
    "commentator",
    "readonly",
]
r"""Default permission level for shared access"""


IsVersionedFile = Literal[
    "true",
    "false",
]
r"""Enable version control for this document"""


class UploadDocumentFileTypedDict(TypedDict):
    file_name: str
    content: Union[bytes, IO[bytes], io.BufferedReader]
    content_type: NotRequired[str]


class UploadDocumentFile(BaseModel):
    file_name: Annotated[
        str, pydantic.Field(alias="fileName"), FieldMetadata(multipart=True)
    ]

    content: Annotated[
        Union[bytes, IO[bytes], io.BufferedReader],
        pydantic.Field(alias=""),
        FieldMetadata(multipart=MultipartFormMetadata(content=True)),
    ]

    content_type: Annotated[
        Optional[str],
        pydantic.Field(alias="Content-Type"),
        FieldMetadata(multipart=True),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["contentType"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UploadDocumentRequestTypedDict(TypedDict):
    r"""Request payload"""

    document_name: str
    r"""Display name for the document"""
    is_versioned_file: IsVersionedFile
    r"""Enable version control for this document"""
    file: UploadDocumentFileTypedDict
    r"""The file to upload (max 1GB)"""
    document_path: NotRequired[str]
    r"""Virtual folder path for organization"""
    alternate_document_name: NotRequired[str]
    r"""Alternative name for search/display"""
    permissions: NotRequired[UploadDocumentPermissions]
    r"""Default permission level for shared access"""
    custom_metadata: NotRequired[str]
    r"""JSON string of custom key-value metadata"""


class UploadDocumentRequest(BaseModel):
    r"""Request payload"""

    document_name: Annotated[
        str, pydantic.Field(alias="documentName"), FieldMetadata(multipart=True)
    ]
    r"""Display name for the document"""

    is_versioned_file: Annotated[
        IsVersionedFile,
        pydantic.Field(alias="isVersionedFile"),
        FieldMetadata(multipart=True),
    ]
    r"""Enable version control for this document"""

    file: Annotated[
        UploadDocumentFile, FieldMetadata(multipart=MultipartFormMetadata(file=True))
    ]
    r"""The file to upload (max 1GB)"""

    document_path: Annotated[
        Optional[str],
        pydantic.Field(alias="documentPath"),
        FieldMetadata(multipart=True),
    ] = None
    r"""Virtual folder path for organization"""

    alternate_document_name: Annotated[
        Optional[str],
        pydantic.Field(alias="alternateDocumentName"),
        FieldMetadata(multipart=True),
    ] = None
    r"""Alternative name for search/display"""

    permissions: Annotated[
        Optional[UploadDocumentPermissions], FieldMetadata(multipart=True)
    ] = "owner"
    r"""Default permission level for shared access"""

    custom_metadata: Annotated[
        Optional[str],
        pydantic.Field(alias="customMetadata"),
        FieldMetadata(multipart=True),
    ] = None
    r"""JSON string of custom key-value metadata"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["documentPath", "alternateDocumentName", "permissions", "customMetadata"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UploadDocumentResponseTypedDict(TypedDict):
    headers: Dict[str, List[str]]
    result: DocumentTypedDict


class UploadDocumentResponse(BaseModel):
    headers: Dict[str, List[str]]

    result: Document
