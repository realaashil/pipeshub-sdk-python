"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .connectorauthtype import ConnectorAuthType
from .connectorscope import ConnectorScope
from pipeshub.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ConnectorTypeTypedDict(TypedDict):
    r"""A connector type from the registry. Represents an available integration
    that can be configured as a connector instance.

    """

    connector_type: NotRequired[str]
    r"""Unique identifier for this connector type"""
    display_name: NotRequired[str]
    r"""Human-readable name"""
    description: NotRequired[str]
    r"""What this connector does"""
    app_group_id: NotRequired[str]
    r"""Application group identifier"""
    app_group: NotRequired[str]
    r"""Application group name (e.g., \"Google Workspace\")"""
    auth_types: NotRequired[List[ConnectorAuthType]]
    r"""Supported authentication methods"""
    supported_scopes: NotRequired[List[ConnectorScope]]
    r"""Supported scope types"""
    supports_sync: NotRequired[bool]
    r"""Whether connector supports data synchronization"""
    supports_agent: NotRequired[bool]
    r"""Whether connector supports AI agent integration"""
    supports_realtime: NotRequired[bool]
    r"""Whether connector supports real-time updates"""
    icon_path: NotRequired[str]
    r"""Path to connector icon"""
    categories: NotRequired[List[str]]
    r"""Categories (e.g., \"Storage\", \"Communication\")"""
    is_beta: NotRequired[bool]
    r"""Whether this is a beta connector"""


class ConnectorType(BaseModel):
    r"""A connector type from the registry. Represents an available integration
    that can be configured as a connector instance.

    """

    connector_type: Annotated[Optional[str], pydantic.Field(alias="connectorType")] = (
        None
    )
    r"""Unique identifier for this connector type"""

    display_name: Annotated[Optional[str], pydantic.Field(alias="displayName")] = None
    r"""Human-readable name"""

    description: Optional[str] = None
    r"""What this connector does"""

    app_group_id: Annotated[Optional[str], pydantic.Field(alias="appGroupId")] = None
    r"""Application group identifier"""

    app_group: Annotated[Optional[str], pydantic.Field(alias="appGroup")] = None
    r"""Application group name (e.g., \"Google Workspace\")"""

    auth_types: Annotated[
        Optional[List[ConnectorAuthType]], pydantic.Field(alias="authTypes")
    ] = None
    r"""Supported authentication methods"""

    supported_scopes: Annotated[
        Optional[List[ConnectorScope]], pydantic.Field(alias="supportedScopes")
    ] = None
    r"""Supported scope types"""

    supports_sync: Annotated[Optional[bool], pydantic.Field(alias="supportsSync")] = (
        None
    )
    r"""Whether connector supports data synchronization"""

    supports_agent: Annotated[Optional[bool], pydantic.Field(alias="supportsAgent")] = (
        None
    )
    r"""Whether connector supports AI agent integration"""

    supports_realtime: Annotated[
        Optional[bool], pydantic.Field(alias="supportsRealtime")
    ] = None
    r"""Whether connector supports real-time updates"""

    icon_path: Annotated[Optional[str], pydantic.Field(alias="iconPath")] = None
    r"""Path to connector icon"""

    categories: Optional[List[str]] = None
    r"""Categories (e.g., \"Storage\", \"Communication\")"""

    is_beta: Annotated[Optional[bool], pydantic.Field(alias="isBeta")] = None
    r"""Whether this is a beta connector"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "connectorType",
                "displayName",
                "description",
                "appGroupId",
                "appGroup",
                "authTypes",
                "supportedScopes",
                "supportsSync",
                "supportsAgent",
                "supportsRealtime",
                "iconPath",
                "categories",
                "isBeta",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    ConnectorType.model_rebuild()
except NameError:
    pass
