"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from pipeshub.types import BaseModel, UNSET_SENTINEL, UnrecognizedStr
import pydantic
from pydantic import model_serializer
from typing import Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


RecordType = Union[
    Literal[
        "FILE",
        "WEBPAGE",
        "COMMENT",
        "MESSAGE",
        "EMAIL",
        "TICKET",
        "OTHERS",
    ],
    UnrecognizedStr,
]
r"""Type of content:
- FILE: Uploaded documents (PDF, DOCX, etc.)
- WEBPAGE: Web pages crawled or bookmarked
- COMMENT: Comments from collaboration tools
- MESSAGE: Chat/messaging content (Slack, Teams)
- EMAIL: Email messages (Gmail, Outlook)
- TICKET: Support tickets (Jira, ServiceNow)
- OTHERS: Miscellaneous content types

"""


Origin = Union[
    Literal[
        "UPLOAD",
        "CONNECTOR",
    ],
    UnrecognizedStr,
]
r"""Source of the record:
- UPLOAD: Manually uploaded via API/UI
- CONNECTOR: Synced from external connector

"""


ConnectorName = Union[
    Literal[
        "ONEDRIVE",
        "GOOGLE_DRIVE",
        "CONFLUENCE",
        "JIRA",
        "SLACK",
        "SHAREPOINT_ONLINE",
        "GMAIL",
        "DROPBOX",
        "OUTLOOK",
        "SERVICENOW",
        "BOOKSTACK",
        "WEB",
    ],
    UnrecognizedStr,
]
r"""Name of the source connector"""


IndexingStatus = Union[
    Literal[
        "NOT_STARTED",
        "PAUSED",
        "IN_PROGRESS",
        "COMPLETED",
        "FAILED",
        "FILE_TYPE_NOT_SUPPORTED",
        "AUTO_INDEX_OFF",
        "EMPTY",
        "ENABLE_MULTIMODAL_MODELS",
        "QUEUED",
    ],
    UnrecognizedStr,
]
r"""Current indexing/processing status:
- NOT_STARTED: Awaiting indexing
- QUEUED: In indexing queue
- IN_PROGRESS: Currently being indexed
- COMPLETED: Successfully indexed and searchable
- FAILED: Indexing failed (check error details)
- PAUSED: Indexing paused by user
- FILE_TYPE_NOT_SUPPORTED: Unsupported file format
- AUTO_INDEX_OFF: Auto-indexing disabled for this record
- EMPTY: File has no extractable content
- ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models

"""


class RecordTypedDict(TypedDict):
    r"""A record represents a single document, file, or content item within a knowledge base.
    Records can originate from file uploads or external connectors (Google Drive, OneDrive, etc.).

    """

    record_name: str
    r"""Display name of the record"""
    record_type: RecordType
    r"""Type of content:
    - FILE: Uploaded documents (PDF, DOCX, etc.)
    - WEBPAGE: Web pages crawled or bookmarked
    - COMMENT: Comments from collaboration tools
    - MESSAGE: Chat/messaging content (Slack, Teams)
    - EMAIL: Email messages (Gmail, Outlook)
    - TICKET: Support tickets (Jira, ServiceNow)
    - OTHERS: Miscellaneous content types

    """
    origin: Origin
    r"""Source of the record:
    - UPLOAD: Manually uploaded via API/UI
    - CONNECTOR: Synced from external connector

    """
    org_id: str
    r"""Organization ID that owns this record"""
    key: NotRequired[str]
    r"""Unique record identifier (UUID format)"""
    external_record_id: NotRequired[str]
    r"""External storage document ID (links to Storage module)"""
    connector_id: NotRequired[str]
    r"""ID of the connector that synced this record (null for uploads)"""
    connector_name: NotRequired[ConnectorName]
    r"""Name of the source connector"""
    kb_id: NotRequired[str]
    r"""Knowledge base ID containing this record"""
    folder_id: NotRequired[str]
    r"""Parent folder ID (null if at KB root)"""
    version: NotRequired[int]
    r"""Current version number (increments on updates)"""
    created_at_timestamp: NotRequired[int]
    r"""Creation timestamp in milliseconds"""
    updated_at_timestamp: NotRequired[int]
    r"""Last update timestamp in milliseconds"""
    indexing_status: NotRequired[IndexingStatus]
    r"""Current indexing/processing status:
    - NOT_STARTED: Awaiting indexing
    - QUEUED: In indexing queue
    - IN_PROGRESS: Currently being indexed
    - COMPLETED: Successfully indexed and searchable
    - FAILED: Indexing failed (check error details)
    - PAUSED: Indexing paused by user
    - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
    - AUTO_INDEX_OFF: Auto-indexing disabled for this record
    - EMPTY: File has no extractable content
    - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models

    """
    is_deleted: NotRequired[bool]
    r"""Soft delete flag"""
    is_archived: NotRequired[bool]
    r"""Archive flag for inactive records"""
    web_url: NotRequired[str]
    r"""Direct URL to access the original content"""
    mime_type: NotRequired[str]
    r"""MIME type of the file content"""
    size_in_bytes: NotRequired[int]
    r"""File size in bytes"""
    extension: NotRequired[str]
    r"""File extension (without dot)"""
    sha256_hash: NotRequired[str]
    r"""SHA-256 hash for content deduplication"""


class Record(BaseModel):
    r"""A record represents a single document, file, or content item within a knowledge base.
    Records can originate from file uploads or external connectors (Google Drive, OneDrive, etc.).

    """

    record_name: Annotated[str, pydantic.Field(alias="recordName")]
    r"""Display name of the record"""

    record_type: Annotated[RecordType, pydantic.Field(alias="recordType")]
    r"""Type of content:
    - FILE: Uploaded documents (PDF, DOCX, etc.)
    - WEBPAGE: Web pages crawled or bookmarked
    - COMMENT: Comments from collaboration tools
    - MESSAGE: Chat/messaging content (Slack, Teams)
    - EMAIL: Email messages (Gmail, Outlook)
    - TICKET: Support tickets (Jira, ServiceNow)
    - OTHERS: Miscellaneous content types

    """

    origin: Origin
    r"""Source of the record:
    - UPLOAD: Manually uploaded via API/UI
    - CONNECTOR: Synced from external connector

    """

    org_id: Annotated[str, pydantic.Field(alias="orgId")]
    r"""Organization ID that owns this record"""

    key: Annotated[Optional[str], pydantic.Field(alias="_key")] = None
    r"""Unique record identifier (UUID format)"""

    external_record_id: Annotated[
        Optional[str], pydantic.Field(alias="externalRecordId")
    ] = None
    r"""External storage document ID (links to Storage module)"""

    connector_id: Annotated[Optional[str], pydantic.Field(alias="connectorId")] = None
    r"""ID of the connector that synced this record (null for uploads)"""

    connector_name: Annotated[
        Optional[ConnectorName], pydantic.Field(alias="connectorName")
    ] = None
    r"""Name of the source connector"""

    kb_id: Annotated[Optional[str], pydantic.Field(alias="kbId")] = None
    r"""Knowledge base ID containing this record"""

    folder_id: Annotated[Optional[str], pydantic.Field(alias="folderId")] = None
    r"""Parent folder ID (null if at KB root)"""

    version: Optional[int] = 0
    r"""Current version number (increments on updates)"""

    created_at_timestamp: Annotated[
        Optional[int], pydantic.Field(alias="createdAtTimestamp")
    ] = None
    r"""Creation timestamp in milliseconds"""

    updated_at_timestamp: Annotated[
        Optional[int], pydantic.Field(alias="updatedAtTimestamp")
    ] = None
    r"""Last update timestamp in milliseconds"""

    indexing_status: Annotated[
        Optional[IndexingStatus], pydantic.Field(alias="indexingStatus")
    ] = None
    r"""Current indexing/processing status:
    - NOT_STARTED: Awaiting indexing
    - QUEUED: In indexing queue
    - IN_PROGRESS: Currently being indexed
    - COMPLETED: Successfully indexed and searchable
    - FAILED: Indexing failed (check error details)
    - PAUSED: Indexing paused by user
    - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
    - AUTO_INDEX_OFF: Auto-indexing disabled for this record
    - EMPTY: File has no extractable content
    - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models

    """

    is_deleted: Annotated[Optional[bool], pydantic.Field(alias="isDeleted")] = False
    r"""Soft delete flag"""

    is_archived: Annotated[Optional[bool], pydantic.Field(alias="isArchived")] = False
    r"""Archive flag for inactive records"""

    web_url: Annotated[Optional[str], pydantic.Field(alias="webUrl")] = None
    r"""Direct URL to access the original content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""MIME type of the file content"""

    size_in_bytes: Annotated[Optional[int], pydantic.Field(alias="sizeInBytes")] = None
    r"""File size in bytes"""

    extension: Optional[str] = None
    r"""File extension (without dot)"""

    sha256_hash: Annotated[Optional[str], pydantic.Field(alias="sha256Hash")] = None
    r"""SHA-256 hash for content deduplication"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_key",
                "externalRecordId",
                "connectorId",
                "connectorName",
                "kbId",
                "folderId",
                "version",
                "createdAtTimestamp",
                "updatedAtTimestamp",
                "indexingStatus",
                "isDeleted",
                "isArchived",
                "webUrl",
                "mimeType",
                "sizeInBytes",
                "extension",
                "sha256Hash",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    Record.model_rebuild()
except NameError:
    pass
