"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from pipeshub.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class DocumentVersionS3TypedDict(TypedDict):
    r"""S3 storage URL for this version"""

    url: NotRequired[str]


class DocumentVersionS3(BaseModel):
    r"""S3 storage URL for this version"""

    url: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DocumentVersionAzureBlobTypedDict(TypedDict):
    r"""Azure Blob storage URL for this version"""

    url: NotRequired[str]


class DocumentVersionAzureBlob(BaseModel):
    r"""Azure Blob storage URL for this version"""

    url: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DocumentVersionLocalTypedDict(TypedDict):
    r"""Local storage path for this version"""

    url: NotRequired[str]
    local_path: NotRequired[str]


class DocumentVersionLocal(BaseModel):
    r"""Local storage path for this version"""

    url: Optional[str] = None

    local_path: Annotated[Optional[str], pydantic.Field(alias="localPath")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["url", "localPath"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DocumentVersionTypedDict(TypedDict):
    r"""Represents a single version entry in a document's version history"""

    version: NotRequired[int]
    r"""Version number (0-indexed, auto-incremented)"""
    user_assigned_version_label: NotRequired[str]
    r"""User-assigned version label (e.g., \"v1.0\", \"Final\")"""
    note: NotRequired[str]
    r"""Note describing this version's changes"""
    extension: NotRequired[str]
    r"""File extension for this version"""
    size: NotRequired[int]
    r"""File size in bytes for this version"""
    mutation_count: NotRequired[int]
    r"""Mutation count at time of version creation"""
    s3: NotRequired[DocumentVersionS3TypedDict]
    r"""S3 storage URL for this version"""
    azure_blob: NotRequired[DocumentVersionAzureBlobTypedDict]
    r"""Azure Blob storage URL for this version"""
    local: NotRequired[DocumentVersionLocalTypedDict]
    r"""Local storage path for this version"""
    created_at: NotRequired[int]
    r"""Version creation timestamp in milliseconds"""
    initiated_by_user_id: NotRequired[str]
    r"""User ID who created this version"""


class DocumentVersion(BaseModel):
    r"""Represents a single version entry in a document's version history"""

    version: Optional[int] = None
    r"""Version number (0-indexed, auto-incremented)"""

    user_assigned_version_label: Annotated[
        Optional[str], pydantic.Field(alias="userAssignedVersionLabel")
    ] = None
    r"""User-assigned version label (e.g., \"v1.0\", \"Final\")"""

    note: Optional[str] = None
    r"""Note describing this version's changes"""

    extension: Optional[str] = None
    r"""File extension for this version"""

    size: Optional[int] = None
    r"""File size in bytes for this version"""

    mutation_count: Annotated[Optional[int], pydantic.Field(alias="mutationCount")] = (
        None
    )
    r"""Mutation count at time of version creation"""

    s3: Optional[DocumentVersionS3] = None
    r"""S3 storage URL for this version"""

    azure_blob: Annotated[
        Optional[DocumentVersionAzureBlob], pydantic.Field(alias="azureBlob")
    ] = None
    r"""Azure Blob storage URL for this version"""

    local: Optional[DocumentVersionLocal] = None
    r"""Local storage path for this version"""

    created_at: Annotated[Optional[int], pydantic.Field(alias="createdAt")] = None
    r"""Version creation timestamp in milliseconds"""

    initiated_by_user_id: Annotated[
        Optional[str], pydantic.Field(alias="initiatedByUserId")
    ] = None
    r"""User ID who created this version"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "version",
                "userAssignedVersionLabel",
                "note",
                "extension",
                "size",
                "mutationCount",
                "s3",
                "azureBlob",
                "local",
                "createdAt",
                "initiatedByUserId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    DocumentVersionLocal.model_rebuild()
except NameError:
    pass
try:
    DocumentVersion.model_rebuild()
except NameError:
    pass
